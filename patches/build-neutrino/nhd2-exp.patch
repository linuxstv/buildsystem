# Commit 95cda4e731818785788870fb6378ee28c76c1b14  22/05/2020
--- nhd2-exp.org/acinclude.m4
+++ nhd2-exp/acinclude.m4
@@ -201,10 +201,14 @@
 AC_DEFUN([TUXBOX_BOXTYPE],[
 
 AC_ARG_WITH(boxtype,
-	[  --with-boxtype          valid values: generic,dgs,gigablue,dreambox,xtrend,fulan,kathrein,ipbox,topfield,fortis_hdbox,octagon,atevio,adb_box,whitebox,vip,homecast,vuplus,azbox,technomate,coolstream,hypercube,venton,xp1000,odin,ixuss,iqonios,e3hd,ebox5000,wetek,edision,hd,gi,xpeedc,formuler,miraclebox,spycat,xsarius,zgemma],
+	[  --with-boxtype          valid values: generic,duckbox,dgs,gigablue,dreambox,xtrend,fulan,kathrein,ipbox,topfield,fs9000,octagon,atevio,hs7,adb_box,adb_2850,vip_v1,vip_2,vip2,homecast,vitamin_hd5000,pace7241,opt9600,vuplus,azbox,technomate,coolstream,hypercube,venton,xp1000,odin,ixuss,iqonios,e3hd,ebox5000,wetek,edision,hd,gi,xpeedc,formuler,miraclebox,spycat,xsarius,zgemma],
 	[case "${withval}" in
-		generic|dgs|gigablue|dreambox|xtrend|fulan|kathrein|ipbox|hl101|topfield|fortis_hdbox|octagon|atevio|adb_box|whitebox|vip|homecast|vuplus|azbox|technomate|coolstream|hypercube|venton|xp1000|odin|ixuss|iqonios|e3hd|ebox5000|wetek|edision|hd|gi|xpeedc|formuler|miraclebox|spycat|xsarius|zgemma)
+		generic|duckbox|dgs|gigablue|dreambox|xtrend|fulan|kathrein|ipbox|hl101|vuplus|azbox|technomate|coolstream|hypercube|venton|xp1000|odin|ixuss|iqonios|e3hd|ebox5000|wetek|edision|hd|gi|xpeedc|formuler|miraclebox|spycat|xsarius|zgemma)
 			BOXTYPE="$withval"
+			;;
+		atemio*)
+			BOXTYPE="atemio"
+			BOXMODEL="$withval"
 			;;
 		cu*)
 			BOXTYPE="dgs"
@@ -226,6 +230,10 @@
 			BOXTYPE="fulan"
 			BOXMODEL="$withval"
 			;;
+		tf*)
+			BOXTYPE="topfield"
+			BOXMODEL="$withval"
+			;;
 		uf*)
 			BOXTYPE="kathrein"
 			BOXMODEL="$withval"
@@ -238,12 +246,32 @@
 			BOXTYPE="duckbox"
 			BOXMODEL="$withval"
 			;;	
-		at*)
-			BOXTYPE="atevio"
-			BOXMODEL="$withval"
-			;;
-		oct*)
-			BOXTYPE="octagon"
+		fs9*)
+			BOXTYPE="fortis"
+			BOXMODEL="$withval"
+			;;
+		hs*)
+			BOXTYPE="fortis"
+			BOXMODEL="$withval"
+			;;
+		vip*)
+			BOXTYPE="vip"
+			BOXMODEL="$withval"
+			;;
+		adb*)
+			BOXTYPE="adb"
+			BOXMODEL="$withval"
+			;;
+		pace*)
+			BOXTYPE="pace"
+			BOXMODEL="$withval"
+			;;
+		vita*)
+			BOXTYPE="vitamin"
+			BOXMODEL="$withval"
+			;;
+		opt*)
+			BOXTYPE="opticum"
 			BOXMODEL="$withval"
 			;;
 		vu*)
@@ -341,10 +369,16 @@
 				valid for xtrend: et4x00,et5x00,et6x00,et7x00, et8000,et8500,et9x00, et10000
 				valid for fulan: spark, spark7162
 				valid for kathrein: ufs910, ufs922, ufs912, ufs913, ufc960
+				valid for topfield: tf7700
 				valid for ipbox: ipbox55, ipbox99, ipbox9900
 				valid for ipbox: hl101
-				valid for atevio: atevio700,atevio7000,atevio7500,atevio7600
-				valid for octagon: octagon1008
+				valid for fortis: fs9000, hs7110, hs7420, hs7810a, hs7119, hs7429, hs7819, hs8200, hs9510
+				valid for vip: vip1_v1, vip1_v2, vip2
+				valid for adb: adb_box, adb_2850
+				valid for atemio: atemio520
+				valid for pace: pace7241
+				valid for vitamin_hd5000: vitamin_hd5000
+				valid for opticum: opt9600
 				valid for vuplus: vusolo,vuduo,vuuno,vuultimo,vuduo2,vusolo2,vusolo4k,vusolose,vuzero
 				valid for azbox: azboxhd,azboxme,azboxminime
 				valid for technomate: tmtwin,tm2t,tmsingle,tmnano
@@ -398,6 +432,13 @@
 				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
 			fi
 			;;
+		tf7700)
+			if test "$BOXTYPE" = "topfield"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
 		ufs910|ufs912|ufs913|ufs922|ufc960)
 			if test "$BOXTYPE" = "kathrein"; then
 				BOXMODEL="$withval"
@@ -419,15 +460,50 @@
 				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
 			fi
 			;;
-		atevio700|atevio7000|atevio7500|atevio7600)
-			if test "$BOXTYPE" = "atevio"; then
-				BOXMODEL="$withval"
-			else
-				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
-			fi
-			;;
-		octagon1008)
-			if test "$BOXTYPE" = "octagon"; then
+		fs9000|hs7110|hs7420|hs7810a|hs7119|hs7429|hs7819|hs8200|hs9510)
+			if test "$BOXTYPE" = "fortis"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		vip1_v1|vip1_v2|vip2)
+			if test "$BOXTYPE" = "vip"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		adb_box|adb_2850)
+			if test "$BOXTYPE" = "adb"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		atemio520)
+			if test "$BOXTYPE" = "atemio"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		pace7241)
+			if test "$BOXTYPE" = "pace"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		vitamin_hd5000)
+			if test "$BOXTYPE" = "vitamin"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		opt9600)
+			if test "$BOXTYPE" = "opticum"; then
 				BOXMODEL="$withval"
 			else
 				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
@@ -598,13 +674,14 @@
 			AC_MSG_ERROR([unsupported value $withval for --with-boxmodel])
 			;;
 	esac],
-	[if test "$BOXTYPE" = "dgs" -o "$BOXTYPE" = "gigablue" -o "$BOXTYPE" = "dreambox" -o "$BOXTYPE" = "xtrend" -o "$BOXTYPE" = "fulan" -o "$BOXTYPE" = "kathrein" -o "$BOXTYPE" = "ipbox" -o "$BOXTYPE" = "atevio" -o "$BOXTYPE" = "octagon" -o "$BOXTYPE" = "vuplus" -o "$BOXTYPE" = "technomate" -o "$BOXTYPE" = "venton" -o "$BOXTYPE" = "ixuss" -o "$BOXTYPE" = "iqonios" -o "$BOXTYPE" = "odin" -o "$BOXTYPE" = "edision" -o "$BOXTYPE" = "hd" -o "$BOXTYPE" = "gi" -o "$BOXTYPE" = "formuler" -o "$BOXTYPE" = "miraclebox" -o "$BOXTYPE" = "spycat" -o "$BOXTYPE" = "xsarius" -o "$BOXTYPE" = "zgemma" && test -z "$BOXMODEL"; then
+	[if test "$BOXTYPE" = "dgs" -o "$BOXTYPE" = "duckbox"-o "$BOXTYPE" = "gigablue" -o "$BOXTYPE" = "dreambox" -o "$BOXTYPE" = "xtrend" -o "$BOXTYPE" = "fulan" -o "$BOXTYPE" = "kathrein" -o "$BOXTYPE" = "ipbox" -o "$BOXTYPE" = "atevio" -o "$BOXTYPE" = "octagon" -o "$BOXTYPE" = "hs7" -o "$BOXTYPE" = "pace" -o "$BOXTYPE" = "adb" -o "$BOXTYPE" = "vitamin" -o "$BOXTYPE" = "vuplus" -o "$BOXTYPE" = "technomate" -o "$BOXTYPE" = "venton" -o "$BOXTYPE" = "ixuss" -o "$BOXTYPE" = "iqonios" -o "$BOXTYPE" = "odin" -o "$BOXTYPE" = "edision" -o "$BOXTYPE" = "hd" -o "$BOXTYPE" = "gi" -o "$BOXTYPE" = "formuler" -o "$BOXTYPE" = "miraclebox" -o "$BOXTYPE" = "spycat" -o "$BOXTYPE" = "xsarius" -o "$BOXTYPE" = "zgemma" && test -z "$BOXMODEL"; then
 		AC_MSG_ERROR([this boxtype $BOXTYPE needs --with-boxmodel])
 	fi])
 
 AC_SUBST(BOXTYPE)
 AC_SUBST(BOXMODEL)
 
+# BOXTYPE is a brand
 AM_CONDITIONAL(BOXTYPE_GENERIC, test "$BOXTYPE" = "generic")
 AM_CONDITIONAL(BOXTYPE_DGS, test "$BOXTYPE" = "dgs")
 AM_CONDITIONAL(BOXTYPE_GIGABLUE, test "$BOXTYPE" = "gigablue")
@@ -614,11 +691,10 @@
 AM_CONDITIONAL(BOXTYPE_KATHREIN, test "$BOXTYPE" = "kathrein")
 AM_CONDITIONAL(BOXTYPE_IPBOX, test "$BOXTYPE" = "ipbox")
 AM_CONDITIONAL(BOXTYPE_HL101, test "$BOXTYPE" = "hl101")
-AM_CONDITIONAL(BOXTYPE_TOPFIELD, test "$BOXTYPE" = "toptfield")
-AM_CONDITIONAL(BOXTYPE_FORTIS_HDBOX, test "$BOXTYPE" = "fortis_hdbox")
-AM_CONDITIONAL(BOXTYPE_OCTAGON, test "$BOXTYPE" = "octagon")
-AM_CONDITIONAL(BOXTYPE_ATEVIO, test "$BOXTYPE" = "atevio")
+AM_CONDITIONAL(BOXTYPE_TOPFIELD, test "$BOXTYPE" = "topfield")
+AM_CONDITIONAL(BOXTYPE_FORTIS, test "$BOXTYPE" = "fortis")
 AM_CONDITIONAL(BOXTYPE_ADB_BOX, test "$BOXTYPE" = "adb_box")
+AM_CONDITIONAL(BOXTYPE_ATEMIO, test "$BOXTYPE" = "atemio")
 AM_CONDITIONAL(BOXTYPE_WHITEBOX, test "$BOXTYPE" = "whitebox")
 AM_CONDITIONAL(BOXTYPE_VIP, test "$BOXTYPE" = "vip")
 AM_CONDITIONAL(BOXTYPE_HOMECAST, test "$BOXTYPE" = "homecast")
@@ -647,6 +723,7 @@
 AM_CONDITIONAL(BOXTYPE_XSARIUS, test "$BOXTYPE" = "xsarius")
 AM_CONDITIONAL(BOXTYPE_ZGEMMA, test "$BOXTYPE" = "zgemma")
 
+# BOXMODEL is a model within a brand
 AM_CONDITIONAL(BOXMODEL_CUBEREVO, test "$BOXMODEL" = "cuberevo")
 AM_CONDITIONAL(BOXMODEL_CUBEREVO_MINI, test "$BOXMODEL" = "cuberevo_mini")
 AM_CONDITIONAL(BOXMODEL_CUBEREVO_MINI2, test "$BOXMODEL" = "cuberevo_mini2")
@@ -687,6 +764,8 @@
 AM_CONDITIONAL(BOXMODEL_SPARK,test "$BOXMODEL" = "spark")
 AM_CONDITIONAL(BOXMODEL_SPARK7162,test "$BOXMODEL" = "spark7162")
 
+AM_CONDITIONAL(BOXMODEL_TF7700, test "$BOXMODEL" = "tf7700")
+
 AM_CONDITIONAL(BOXMODEL_UFS910, test "$BOXMODEL" = "ufs910")
 AM_CONDITIONAL(BOXMODEL_UFS912, test "$BOXMODEL" = "ufs912")
 AM_CONDITIONAL(BOXMODEL_UFS913, test "$BOXMODEL" = "ufs913")
@@ -699,12 +778,25 @@
 
 AM_CONDITIONAL(BOXMODEL_HL101, test "$BOXMODEL" = "hl101")
 
-AM_CONDITIONAL(BOXMODEL_ATEVIO700, test "$BOXMODEL" = "atevio700")
-AM_CONDITIONAL(BOXMODEL_ATEVIO7000, test "$BOXMODEL" = "atevio7000")
-AM_CONDITIONAL(BOXMODEL_ATEVIO7500, test "$BOXMODEL" = "atevio7500")
-AM_CONDITIONAL(BOXMODEL_ATEVIO7600, test "$BOXMODEL" = "atevio7600")
-
-AM_CONDITIONAL(BOXMODEL_OCTAGON_1008, test "$BOXMODEL" = "octagon1008")
+AM_CONDITIONAL(BOXMODEL_FS9000, test "$BOXMODEL" = "fs9000")
+AM_CONDITIONAL(BOXMODEL_HS7110, test "$BOXMODEL" = "hs7110")
+AM_CONDITIONAL(BOXMODEL_HS7420, test "$BOXMODEL" = "hs7420")
+AM_CONDITIONAL(BOXMODEL_HS7810A, test "$BOXMODEL" = "hs7810a")
+AM_CONDITIONAL(BOXMODEL_HS7119, test "$BOXMODEL" = "hs7119")
+AM_CONDITIONAL(BOXMODEL_HS7429, test "$BOXMODEL" = "hs7429")
+AM_CONDITIONAL(BOXMODEL_HS7819, test "$BOXMODEL" = "hs7819")
+AM_CONDITIONAL(BOXMODEL_HS8200, test "$BOXMODEL" = "hs8200")
+AM_CONDITIONAL(BOXMODEL_HS9510, test "$BOXMODEL" = "hs9510")
+
+AM_CONDITIONAL(BOXMODEL_VIP1_V1, test "$BOXMODEL" = "vip1_v1")
+AM_CONDITIONAL(BOXMODEL_VIP1_V2, test "$BOXMODEL" = "vip1_v2")
+AM_CONDITIONAL(BOXMODEL_VIP2, test "$BOXMODEL" = "vip2")
+AM_CONDITIONAL(BOXMODEL_ADB_BOX, test "$BOXMODEL" = "adb_box")
+AM_CONDITIONAL(BOXMODEL_ADB_2850, test "$BOXMODEL" = "adb_2850")
+AM_CONDITIONAL(BOXMODEL_PACE7241, test "$BOXMODEL" = "pace7241")
+AM_CONDITIONAL(BOXMODEL_VITAMIN_HD5000, test "$BOXMODEL" = "vitamin_hd5000")
+AM_CONDITIONAL(BOXMODEL_OPT9600, test "$BOXMODEL" = "opt9600")
+AM_CONDITIONAL(BOXMODEL_ATEMIO520, test "$BOXMODEL" = "atemio520")
 
 AM_CONDITIONAL(BOXMODEL_VUSOLO2, test "$BOXMODEL" = "vusolo2")
 AM_CONDITIONAL(BOXMODEL_VUDUO2, test "$BOXMODEL" = "vuduo2")
@@ -785,6 +877,7 @@
 AM_CONDITIONAL(BOXMODEL_LC, test "$BOXMODEL" = "lc")
 AM_CONDITIONAL(BOXMODEL_SH1, test "$BOXMODEL" = "sh1")
 
+# PLATFORM is derived from a BOXTYPE (a brand)
 if test "$BOXTYPE" = "generic"; then
 	AC_DEFINE(PLATFORM_GENERIC, 1, [building for generic])
 elif test "$BOXTYPE" = "dgs"; then
@@ -797,6 +890,8 @@
 	AC_DEFINE(PLATFORM_XTREND, 1, [building for xtrend])
 elif test "$BOXTYPE" = "fulan"; then
 	AC_DEFINE(PLATFORM_FULAN, 1, [building for fulan])
+elif test "$BOXTYPE" = "topfield"; then
+	AC_DEFINE(PLATFORM_TOPFIELD, 1, [building for topfield])
 elif test "$BOXTYPE" = "kathrein"; then
 	AC_DEFINE(PLATFORM_KATHREIN, 1, [building for kathrein])
 elif test "$BOXTYPE" = "ipbox"; then
@@ -805,18 +900,20 @@
 	AC_DEFINE(HAVE_DUCKBOX_HARDWARE, 1, [building for a duckbox])	
 elif test "$BOXTYPE" = "topfield"; then
 	AC_DEFINE(PLATFORM_TF7700, 1, [building for topfield])
-elif test "$BOXTYPE" = "fortis_hdbox"; then
-	AC_DEFINE(PLATFORM_FORTIS_HDBOX, 1, [building for fortis_hdbox])
-elif test "$BOXTYPE" = "octagon"; then
-	AC_DEFINE(PLATFORM_OCTAGON, 1, [building for octagon])
-elif test "$BOXTYPE" = "atevio"; then
-	AC_DEFINE(PLATFORM_ATEVIO, 1, [building for atevio])
-elif test "$BOXTYPE" = "adb_box"; then
-	AC_DEFINE(PLATFORM_ADB_BOX, 1, [building for adb_box])
-elif test "$BOXTYPE" = "whitebox"; then
-	AC_DEFINE(PLATFORM_WHITEBOX, 1, [building for whitebox])
+elif test "$BOXTYPE" = "fortis"; then
+	AC_DEFINE(PLATFORM_FORTIS, 1, [building for fortis])
+elif test "$BOXTYPE" = "adb"; then
+	AC_DEFINE(PLATFORM_ADB, 1, [building for adb])
+elif test "$BOXTYPE" = "atemio"; then
+	AC_DEFINE(PLATFORM_ATEMIO, 1, [building for atemio])
+elif test "$BOXTYPE" = "pace"; then
+	AC_DEFINE(PLATFORM_PACE, 1, [building for pace])
+elif test "$BOXTYPE" = "vitamin"; then
+	AC_DEFINE(PLATFORM_VITAMIN, 1, [building for vitamin])
 elif test "$BOXTYPE" = "vip"; then
 	AC_DEFINE(PLATFORM_VIP, 1, [building for vip])
+elif test "$BOXTYPE" = "opticumv"; then
+	AC_DEFINE(PLATFORM_OPTICUM, 1, [building for opticum])
 elif test "$BOXTYPE" = "homecast"; then
 	AC_DEFINE(PLATFORM_HOMECAST, 1, [building for homecast])
 elif test "$BOXTYPE" = "vuplus"; then
@@ -865,6 +962,7 @@
 	AC_DEFINE(PLATFORM_ZGEMMA, 1, [building for zgemma])
 fi
 
+# Define the BOXMODELs
 if test "$BOXMODEL" = "cuberevo"; then
 	AC_DEFINE(PLATFORM_CUBEREVO, 1, [building for cuberevo])
 elif test "$BOXMODEL" = "cuberevo_mini"; then
@@ -938,6 +1036,9 @@
 elif test "$BOXMODEL" = "spark7162"; then
 	AC_DEFINE(PLATFORM_SPARK7162, 1, [building for spark 7162])
 
+elif test "$BOXMODEL" = "tf7700"; then
+	AC_DEFINE(BOXMODEL_TF7700, 1, [building for topfield tf7700])
+
 elif test "$BOXMODEL" = "ufs910"; then
 	AC_DEFINE(PLATFORM_UFS910, 1, [building for ufs910])
 elif test "$BOXMODEL" = "ufs912"; then
@@ -959,17 +1060,16 @@
 elif test "$BOXMODEL" = "hl101"; then
 	AC_DEFINE(BOXMODEL_HL101, 1, [hl101])
 
-elif test "$BOXMODEL" = "atevio700"; then
-	AC_DEFINE(BOXMODEL_ATEVIO700, 1, [building for atevio700])
-elif test "$BOXMODEL" = "atevio7000"; then
-	AC_DEFINE(BOXMODEL_ATEVIO7000, 1, [building for atevio7000])
-elif test "$BOXMODEL" = "atevio7500"; then
-	AC_DEFINE(BOXMODEL_ATEVIO7500, 1, [building for atevio7500])
-elif test "$BOXMODEL" = "atevio7600"; then
-	AC_DEFINE(BOXMODEL_ATEVIO7600, 1, [building for atevio7600])
-
-elif test "$BOXMODEL" = "octagon1008"; then
-	AC_DEFINE(BOXMODEL_OCTAGON_1008, 1, [building for octagon1008])
+elif test "$BOXMODEL" = "opt9600"; then
+	AC_DEFINE(BOXMODEL_OPT9600, 1, [building for opticum hd 9600])
+
+elif test "$BOXMODEL" = "adb_box"; then
+	AC_DEFINE(BOXMODEL_ADB_BOX, 1, [building for adb iti-5800])
+elif test "$BOXMODEL" = "adb2850"; then
+	AC_DEFINE(BOXMODEL_ADB2850, 1, [building for adb iti-2850])
+
+elif test "$BOXMODEL" = "atemio520"; then
+	AC_DEFINE(BOXMODEL_ATEMIO520, 1, [building for atemio am 520 hd])
 
 elif test "$BOXMODEL" = "vusolo2"; then
 	AC_DEFINE(BOXMODEL_VUSOLO2, 1, [vuplus solo2])
@@ -2146,4 +2246,3 @@
 ])
 
 
-
--- nhd2-exp.org/lib/libdvbsub/dvbsubtitle.cpp
+++ nhd2-exp/lib/libdvbsub/dvbsubtitle.cpp
@@ -21,9 +21,16 @@
 #include <libavformat/avformat.h>
 #include <libavcodec/avcodec.h>
 #include <libavutil/avutil.h>
+#include <libavcodec/version.h>
 }
 #include "driver/framebuffer.h"
 #include "Debug.hpp"
+
+#if LIBAVCODEC_VERSION_INT <= AV_VERSION_INT(57, 1, 99)
+	#define CODEC_DVB_SUB CODEC_ID_DVB_SUBTITLE
+#else
+	#define CODEC_DVB_SUB AV_CODEC_ID_DVB_SUBTITLE
+#endif
 
 // Set these to 'true' for debug output:
 static bool DebugConverter = false;
--- nhd2-exp.org/lib/libeplayer3/container/container_ffmpeg.c
+++ nhd2-exp/lib/libeplayer3/container/container_ffmpeg.c
@@ -38,14 +38,10 @@
 #include <pthread.h>
 
 #include <libavutil/avutil.h>
-#if LIBAVCODEC_VERSION_MAJOR > 54
 #include <libavutil/time.h>
-#endif
 #include <libavformat/avformat.h>
-#if LIBAVCODEC_VERSION_MAJOR > 54
 #include <libavutil/opt.h>
-#endif
-
+#include <libavcodec/avcodec.h>
 #include "common.h"
 #include "misc.h"
 #include "debug.h"
@@ -55,9 +51,7 @@
 #include "subtitle.h"
 
 
-#if LIBAVCODEC_VERSION_MAJOR > 54
 #define AVCODEC_MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audio
-#endif
 
 /* ***************************** */
 /* Makros/Constants              */
@@ -146,124 +140,107 @@
 {
 	switch (codec->codec_id)
 	{
-		case CODEC_ID_MPEG1VIDEO:
+		case AV_CODEC_ID_MPEG1VIDEO:
 			return "V_MPEG1";
 			
-		case CODEC_ID_MPEG2VIDEO:
+		case AV_CODEC_ID_MPEG2VIDEO:
 			return "V_MPEG2";
 			
-		case CODEC_ID_H263:
-		case CODEC_ID_H263P:
-		case CODEC_ID_H263I:
+		case AV_CODEC_ID_H263:
+		case AV_CODEC_ID_H263P:
+		case AV_CODEC_ID_H263I:
 			return "V_H263";
 			
-		case CODEC_ID_FLV1:
+		case AV_CODEC_ID_FLV1:
 			return "V_FLV";
 			
-		case CODEC_ID_VP5:
-		case CODEC_ID_VP6:
-		case CODEC_ID_VP6F:
+		case AV_CODEC_ID_VP5:
+		case AV_CODEC_ID_VP6:
+		case AV_CODEC_ID_VP6F:
 			return "V_VP6";
 			
-		case CODEC_ID_RV10:
-		case CODEC_ID_RV20:
+		case AV_CODEC_ID_RV10:
+		case AV_CODEC_ID_RV20:
 			return "V_RMV";
 			
-		case CODEC_ID_MPEG4:
-#if LIBAVCODEC_VERSION_MAJOR < 53
-		case CODEC_ID_XVID:
-#endif
-		case CODEC_ID_MSMPEG4V1:
-		case CODEC_ID_MSMPEG4V2:
-		case CODEC_ID_MSMPEG4V3:
+		case AV_CODEC_ID_MPEG4:
+		case AV_CODEC_ID_MSMPEG4V1:
+		case AV_CODEC_ID_MSMPEG4V2:
+		case AV_CODEC_ID_MSMPEG4V3:
 			return "V_MSCOMP";
 			
-		case CODEC_ID_WMV1:
+		case AV_CODEC_ID_WMV1:
 			*version = 1;
 			return "V_WMV";
 			
-		case CODEC_ID_WMV2:
+		case AV_CODEC_ID_WMV2:
 			*version = 2;
 			return "V_WMV";
 			
-		case CODEC_ID_WMV3:
+		case AV_CODEC_ID_WMV3:
 			*version = 3;
 			return "V_WMV";
 			
-		case CODEC_ID_VC1:
+		case AV_CODEC_ID_VC1:
 			return "V_VC1";
 			
-		case CODEC_ID_H264:
-#if LIBAVCODEC_VERSION_MAJOR < 54
-		case CODEC_ID_FFH264:
-#endif
+		case AV_CODEC_ID_H264:
 			return "V_MPEG4/ISO/AVC";
 		
-		case CODEC_ID_AVS:
+		case AV_CODEC_ID_AVS:
 			return "V_AVS";
 			
-		case CODEC_ID_MP2:
+		case AV_CODEC_ID_MP2:
 			return "A_MPEG/L3";
 			
-		case CODEC_ID_MP3:
+		case AV_CODEC_ID_MP3:
 			return "A_MP3";
 			
-		case CODEC_ID_AAC:
+		case AV_CODEC_ID_AAC:
 			return "A_AAC";
 			
-		case CODEC_ID_AC3:
+		case AV_CODEC_ID_AC3:
 			return "A_AC3";
 			
-		case CODEC_ID_DTS:
+		case AV_CODEC_ID_DTS:
 			return "A_DTS";
 		
-//#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 72, 2)			
-//		case AV_CODEC_ID_EAC3:
-//			return "A_EAC3";
-//#endif			
-			
-		case CODEC_ID_WMAV1:
-		case CODEC_ID_WMAV2:
-		case 86056: //CODEC_ID_WMAPRO
+			
+		case AV_CODEC_ID_WMAV1:
+		case AV_CODEC_ID_WMAV2:
+		case 86056: //AV_CODEC_ID_WMAPRO
 			return "A_WMA";
 			
-		case CODEC_ID_MLP:
+		case AV_CODEC_ID_MLP:
 			return "A_MLP";
 			
-		case CODEC_ID_RA_144:
+		case AV_CODEC_ID_RA_144:
 			return "A_RMA";
 			
-		case CODEC_ID_RA_288:
+		case AV_CODEC_ID_RA_288:
 			return "A_RMA";
 			
-		case CODEC_ID_VORBIS:
+		case AV_CODEC_ID_VORBIS:
 			return "A_IPCM"; //return "A_VORBIS";
 			
-		case CODEC_ID_FLAC: //86030
+		case AV_CODEC_ID_FLAC: //86030
 			return "A_IPCM"; //return "A_FLAC";
 			
 		/* subtitle */
-		case CODEC_ID_SSA:
+		case AV_CODEC_ID_SSA:
 			return "S_TEXT/ASS"; /* Hellmaster1024: seems to be ASS instead of SSA */
 			
-		case CODEC_ID_TEXT: /* Hellmaster1024: i dont have most of this, but lets hope it is normal text :-) */
-		case CODEC_ID_DVD_SUBTITLE:
-		case CODEC_ID_DVB_SUBTITLE:
-		case CODEC_ID_XSUB:
-		case CODEC_ID_MOV_TEXT:
-#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(56, 72, 2)      
-		case CODEC_ID_HDMV_PGS_SUBTITLE:
-#endif
-
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52,38,1)
-		case CODEC_ID_DVB_TELETEXT:
-#endif      
+		case AV_CODEC_ID_TEXT: /* Hellmaster1024: i dont have most of this, but lets hope it is normal text :-) */
+		case AV_CODEC_ID_DVD_SUBTITLE:
+		case AV_CODEC_ID_DVB_SUBTITLE:
+		case AV_CODEC_ID_XSUB:
+		case AV_CODEC_ID_MOV_TEXT:
+		case AV_CODEC_ID_HDMV_PGS_SUBTITLE:
+		case AV_CODEC_ID_DVB_TELETEXT:
 			return "S_TEXT/SRT"; /* fixme */
 		
-#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 72, 2)
-		case CODEC_ID_SRT:
+		case AV_CODEC_ID_SRT:
 			return "S_TEXT/SRT"; /* fixme */
-#endif 
 
 		default:
 			if (codec->codec_type == AVMEDIA_TYPE_AUDIO)
@@ -271,7 +248,6 @@
 			else
 				ffmpeg_err("ERROR! CODEC NOT FOUND -> %d\n",codec->codec_id);
 	}
-	
 	return NULL;
 }
 
@@ -332,28 +308,16 @@
 /* search for metatdata in context and stream
  * and map it to our metadata.
  */
-#if LIBAVCODEC_VERSION_MAJOR < 54
-static char* searchMeta(AVMetadata *metadata, char* ourTag)
-#else
 static char* searchMeta(AVDictionary * metadata, char* ourTag)
-#endif
 {
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	AVMetadataTag *tag = NULL;
-#else
 	AVDictionaryEntry *tag = NULL;
-#endif
 	int i = 0;
 
 	while (metadata_map[i] != NULL)
 	{
 		if (strcmp(ourTag, metadata_map[i]) == 0)
 		{
-#if LIBAVCODEC_VERSION_MAJOR < 54
-			while ((tag = av_metadata_get(metadata, "", tag, AV_METADATA_IGNORE_SUFFIX)))
-#else
 			while ((tag = av_dict_get(metadata, "", tag, AV_DICT_IGNORE_SUFFIX)))
-#endif
 			{
 				if (strcmp(tag->key, metadata_map[ i + 1 ]) == 0)
 				{
@@ -494,11 +458,7 @@
 			}
 			else
 			{
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				lastSeek = currentReadPosition = url_ftell(avContext->pb);
-#else
 				lastSeek = currentReadPosition = avio_tell(avContext->pb);
-#endif
 				gotlastPts = 1;
 
 #ifndef use_sec_to_seek
@@ -538,11 +498,7 @@
 
 			int index = packet.stream_index;
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-			currentReadPosition = url_ftell(avContext->pb);
-#else
 			currentReadPosition = avio_tell(avContext->pb);
-#endif
 
 			if (context->manager->video->Command(context, MANAGER_GET_TRACK, &videoTrack) < 0)
 				ffmpeg_err("error getting video track\n");
@@ -626,11 +582,7 @@
 						{
 							int decoded_data_size = samples_size;
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
-							bytesDone = avcodec_decode_audio3(( (AVStream*) audioTrack->stream)->codec, (short *)(samples), &decoded_data_size, &avpkt);
-#else
-							bytesDone = avcodec_decode_audio2(( (AVStream*) audioTrack->stream)->codec, (short *)(samples), &decoded_data_size, avpkt.data, avpkt.size);
-#endif
+							bytesDone = avcodec_decode_audio4(( (AVStream*) audioTrack->stream)->codec, (short *)(samples), &decoded_data_size, &avpkt);
 
 							if(bytesDone < 0) // Error Happend
 							    break;
@@ -735,7 +687,7 @@
 						duration=((float)packet.duration)/1000.0;
 					else if(packet.convergence_duration != 0 && packet.convergence_duration != AV_NOPTS_VALUE )
 						duration=((float)packet.convergence_duration)/1000.0;		    
-					else if(((AVStream*)subtitleTrack->stream)->codec->codec_id == CODEC_ID_SSA)
+					else if(((AVStream*)subtitleTrack->stream)->codec->codec_id == AV_CODEC_ID_SSA)
 					{
 						/*Hellmaster1024 if the duration is not stored in packet.duration or
 						  packet.convergence_duration we need to calculate it any other way, for SSA it is stored in
@@ -759,11 +711,7 @@
 							AVSubtitle sub;
 							int got_sub_ptr;
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)			   
 							if (avcodec_decode_subtitle2(((AVStream*) subtitleTrack->stream)->codec, &sub, &got_sub_ptr, &packet) < 0)
-#else
-							if (avcodec_decode_subtitle( ((AVStream*) subtitleTrack->stream)->codec, &sub, &got_sub_ptr, packet.data, packet.size ) < 0)
-#endif
 							{
 							    ffmpeg_err("error decoding subtitle\n");
 							} 
@@ -793,7 +741,7 @@
 							}
 						}
 						else
-						if(((AVStream*)subtitleTrack->stream)->codec->codec_id == CODEC_ID_SSA)
+						if(((AVStream*)subtitleTrack->stream)->codec->codec_id == AV_CODEC_ID_SSA)
 						{
 							SubtitleData_t data;
 
@@ -893,19 +841,11 @@
 	avcodec_register_all();
 	av_register_all();
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	if ((err = av_open_input_file(&avContext, filename, NULL, 0, NULL)) != 0) 
-#else
 	if ((err = avformat_open_input(&avContext, filename, NULL, 0)) != 0)
-#endif
 	{
 		char error[512];
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-		ffmpeg_err("av_open_input_file failed %d (%s)\n", err, filename);
-#else
 		ffmpeg_err("avformat_open_input failed %d (%s)\n", err, filename);
-#endif
 		//av_strerror(err, error, 512);
 		ffmpeg_err("Cause: %s\n", error);
 
@@ -923,26 +863,16 @@
 
 	ffmpeg_printf(20, "find_streaminfo\n");
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	if (av_find_stream_info(avContext) < 0) 
-	{
-		ffmpeg_err("Error av_find_stream_info\n");
-#else
 	if (avformat_find_stream_info(avContext, NULL) < 0) 
 	{
 		ffmpeg_err("Error avformat_find_stream_info\n");
-#endif
 
 #ifdef this_is_ok
 		/* crow reports that sometimes this returns an error
 		* but the file is played back well. so remove this
 		* until other works are done and we can prove this.
 		*/
-#if LIBAVFORMAT_VERSION_MAJOR < 54
- 		av_close_input_file(avContext);
-#else
 		avformat_close_input(&avContext);
-#endif		
 		releaseMutex(FILENAME, __FUNCTION__,__LINE__);
 		return cERR_CONTAINER_FFMPEG_STREAM;
 #endif
@@ -950,11 +880,7 @@
 
 	ffmpeg_printf(20, "dump format\n");
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	dump_format(avContext, 0, filename, 0);
-#else
 	av_dump_format(avContext, 0, filename, 0);
-#endif
 
 	ffmpeg_printf(1, "number streams %d\n", avContext->nb_streams);
 
@@ -977,11 +903,7 @@
 
 		switch (stream->codec->codec_type) 
 		{
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)	  
 			case AVMEDIA_TYPE_VIDEO:
-#else
-			case CODEC_TYPE_VIDEO:
-#endif        
 			ffmpeg_printf(10, "CODEC_TYPE_VIDEO %d\n",stream->codec->codec_type);
 
 			if (encoding != NULL) 
@@ -1055,11 +977,7 @@
 			break;
 	    
 			// audio codec
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)	  
 			case AVMEDIA_TYPE_AUDIO:
-#else
-			case CODEC_TYPE_AUDIO:
-#endif        
 			ffmpeg_printf(10, "CODEC_TYPE_AUDIO %d\n",stream->codec->codec_type);
 
 			if (encoding != NULL) 
@@ -1067,17 +985,9 @@
 				track.type = eTypeES;
 				
 				// language description
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				AVMetadataTag *lang;
-#else
 				AVDictionaryEntry *lang;
-#endif
-
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				lang = av_metadata_get(stream->metadata, "language", NULL, 0);
-#else
+
 				lang = av_dict_get(stream->metadata, "language", NULL, 0);
-#endif
 
 				if (lang)
 					track.Name = strdup(lang->value);
@@ -1113,17 +1023,13 @@
 
 					AVCodec *codec = avcodec_find_decoder(stream->codec->codec_id);
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-					if(codec != NULL && !avcodec_open(stream->codec, codec))
-#else
 					if(codec != NULL && !avcodec_open2(stream->codec, codec, NULL))
-#endif					  
 						printf("AVCODEC__INIT__SUCCESS\n");
 					else
 						printf("AVCODEC__INIT__FAILED\n");
 				}
 				// aac
-				else if(stream->codec->codec_id == CODEC_ID_AAC) 
+				else if(stream->codec->codec_id == AV_CODEC_ID_AAC) 
 				{
 					ffmpeg_printf(10,"Create AAC ExtraData\n");
 					ffmpeg_printf(10,"stream->codec->extradata_size %d\n", stream->codec->extradata_size);
@@ -1175,7 +1081,7 @@
 					track.have_aacheader = 1;
 				} 
 				// wma
-				else if(stream->codec->codec_id == CODEC_ID_WMAV1 || stream->codec->codec_id == CODEC_ID_WMAV2 || 86056 ) //CODEC_ID_WMAPRO) //if (stream->codec->extradata_size > 0)
+				else if(stream->codec->codec_id == AV_CODEC_ID_WMAV1 || stream->codec->codec_id == AV_CODEC_ID_WMAV2 || 86056 ) //AV_CODEC_ID_WMAPRO) //if (stream->codec->extradata_size > 0)
 				{
 					ffmpeg_printf(10,"Create WMA ExtraData\n");
 					track.aacbuflen = 104 + stream->codec->extradata_size;
@@ -1218,13 +1124,13 @@
 					switch(stream->codec->codec_id) 
 					{
 						//TODO: What code for lossless ?
-						case 86056/*CODEC_ID_WMAPRO*/:
+						case 86056/*AV_CODEC_ID_WMAPRO*/:
 							codec_id = WMA_VERSION_9_PRO;
 							break;
-						case CODEC_ID_WMAV2:
+						case AV_CODEC_ID_WMAV2:
 							codec_id = WMA_VERSION_2_9 ;
 							break;
-						case CODEC_ID_WMAV1:
+						case AV_CODEC_ID_WMAV1:
 						default:
 							codec_id = WMA_VERSION_1;
 							break;
@@ -1279,21 +1185,12 @@
 			break;
 	    
 			// subtitle
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
 			case AVMEDIA_TYPE_SUBTITLE:
 			{
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				AVMetadataTag * lang;
-#else
 				AVDictionaryEntry * lang;
-#endif
 				ffmpeg_printf(10, "CODEC_TYPE_SUBTITLE %d\n",stream->codec->codec_type);
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				lang = av_metadata_get(stream->metadata, "language", NULL, 0);
-#else
 				lang = av_dict_get(stream->metadata, "language", NULL, 0);
-#endif	     
 
 				if (lang)
 					track.Name        = strdup(lang->value);
@@ -1354,7 +1251,6 @@
 			default:
 				ffmpeg_err("not handled or unknown codec_type %d\n", stream->codec->codec_type);
 				break;	 
-#endif	 
 		} /* switch (stream->codec->codec_type) */
 
 	} /* for */
@@ -1449,12 +1345,7 @@
 
 	if (avContext != NULL) 
 	{
-#if LIBAVFORMAT_VERSION_MAJOR < 54
- 		av_close_input_file(avContext);
- 		avContext = NULL;
-#else
 		avformat_close_input(&avContext);
-#endif		
 	}
 
 	isContainerRunning = 0;
@@ -1468,11 +1359,7 @@
 static int container_ffmpeg_seek_bytes(off_t pos) 
 {
 	int flag = AVSEEK_FLAG_BYTE;
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	off_t current_pos = url_ftell(avContext->pb);
-#else
 	off_t current_pos = avio_tell(avContext->pb);
-#endif
 
 	ffmpeg_printf(20, "seeking to position %lld (bytes)\n", pos);
 
@@ -1485,11 +1372,7 @@
 		return cERR_CONTAINER_FFMPEG_ERR;
 	}    
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	ffmpeg_printf(30, "current_pos after seek %lld\n", url_ftell(avContext->pb));
-#else
 	ffmpeg_printf(30, "current_pos after seek %lld\n", avio_tell(avContext->pb));
-#endif
 
 	return cERR_CONTAINER_FFMPEG_NO_ERROR;
 }
@@ -1499,11 +1382,7 @@
 {
 	int flag = AVSEEK_FLAG_BYTE;
 	off_t newpos;
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	off_t current_pos = url_ftell(avContext->pb);
-#else
 	off_t current_pos = avio_tell(avContext->pb);
-#endif
 
 	if (start == -1)
 		start = current_pos;
@@ -1532,11 +1411,7 @@
 		return cERR_CONTAINER_FFMPEG_ERR;
 	}    
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	ffmpeg_printf(30, "current_pos after seek %lld\n", url_ftell(avContext->pb));
-#else
 	ffmpeg_printf(30, "current_pos after seek %lld\n", avio_tell(avContext->pb));
-#endif
 
 	return cERR_CONTAINER_FFMPEG_NO_ERROR;
 }
@@ -1567,11 +1442,7 @@
 
 	if (pos == -1)
 	{
-#if LIBAVCODEC_VERSION_MAJOR < 54
-		pos = url_ftell(avContext->pb);
-#else
 		pos = avio_tell(avContext->pb);
-#endif
 	}
 
 	if (pts == -1)
@@ -1700,11 +1571,7 @@
  * about 10 seconds, backward does not work.
  */
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-		off_t pos = url_ftell(avContext->pb);
-#else
 		off_t pos = avio_tell(avContext->pb);
-#endif
 
 		ffmpeg_printf(10, "pos %lld %d\n", pos, avContext->bit_rate);
 
--- neutrino-hd2.org/src/driver/rcinput.h
+++ neutrino-hd2/src/driver/rcinput.h
@@ -1,6 +1,6 @@
 /*
 	Neutrino-GUI  -   DBoxII-Project
-	
+
 	$Id: rcinput.h 2013/10/12 mohousch Exp $
 
 	Copyright (C) 2001 Steffen Hehn 'McClean'
@@ -84,48 +84,48 @@
 #define KEY_GAMES        0x1a1
 #endif
 
-// this values are token from cuberevo3000hd
-#ifndef KEY_PIP	
+// these values are taken from cuberevo3000hd
+#ifndef KEY_PIP
 #define KEY_PIP		0x041
 #endif
 
-#ifndef KEY_PIPPOS	
+#ifndef KEY_PIPPOS
 #define KEY_PIPPOS	0x0BE
 #endif
 
-#ifndef KEY_PIPSWAP 
+#ifndef KEY_PIPSWAP
 #define KEY_PIPSWAP	0x0BF
 #endif
 
-#ifndef __KEY_PIPSUBCH	
+#ifndef __KEY_PIPSUBCH
 #define KEY_PIPSUBCH	0x0C0
 #endif
 
-#ifndef KEY_BOOKMARK	
+#ifndef KEY_BOOKMARK
 #define	KEY_BOOKMARK	0x03f
 #endif
 
-#ifndef KEY_MUSIC	
+#ifndef KEY_MUSIC
 #define KEY_MUSIC	0x0c1
 #endif
 
-#ifndef KEY_PICTURE	
+#ifndef KEY_PICTURE
 #define KEY_PICTURE	0x03e
 #endif
 
-#ifndef KEY_REPEAT	
+#ifndef KEY_REPEAT
 #define	KEY_REPEAT	0x040
 #endif
 
-#ifndef KEY_SLOW	
+#ifndef KEY_SLOW
 #define KEY_SLOW	0x199
 #endif
 
-#ifndef KEY_MULTFEED	
+#ifndef KEY_MULTFEED
 #define KEY_MULTIFEED	0x0bd
 #endif
 
-#ifndef KEY_DVBSUB	
+#ifndef KEY_DVBSUB
 #define KEY_DVBSUB	0x172
 #endif
 
@@ -146,59 +146,60 @@
 //
 enum
 {
-	RC_0		= KEY_0,	    
-	RC_1		= KEY_1,	    
-	RC_2		= KEY_2,	    
-	RC_3		= KEY_3,	    
-	RC_4		= KEY_4,	    
-	RC_5		= KEY_5,	    
-	RC_6		= KEY_6,	    
-	RC_7		= KEY_7,	    
-	RC_8		= KEY_8,	    
+	RC_0		= KEY_0,
+	RC_1		= KEY_1,
+	RC_2		= KEY_2,
+	RC_3		= KEY_3,
+	RC_4		= KEY_4,
+	RC_5		= KEY_5,
+	RC_6		= KEY_6,
+	RC_7		= KEY_7,
+	RC_8		= KEY_8,
 	RC_9		= KEY_9,
-	    		
-	RC_up		= KEY_UP,	    
-	RC_left		= KEY_LEFT,	    
-	RC_right	= KEY_RIGHT,	    
-	RC_down		= KEY_DOWN,	    		
-	RC_spkr		= KEY_MUTE,	   		
-	RC_minus        = KEY_VOLUMEDOWN,   
-	RC_plus         = KEY_VOLUMEUP,     
-
-	RC_standby	= KEY_POWER,	    
-			
-	RC_home         = KEY_HOME,         
-	RC_setup	= KEY_MENU,	    
-			
-	RC_page_up	= KEY_PAGEUP,	   
-	RC_page_down	= KEY_PAGEDOWN,	    
-			
-	RC_ok		= KEY_OK,	    
-			
-	RC_red		= KEY_RED,	    
-	RC_green	= KEY_GREEN,	    
-	RC_yellow	= KEY_YELLOW,	    
-	RC_blue		= KEY_BLUE,	    
+	    
+	RC_up		= KEY_UP,
+	RC_left		= KEY_LEFT,
+	RC_right	= KEY_RIGHT,
+	RC_down		= KEY_DOWN,	    
+	RC_spkr		= KEY_MUTE,	   
+	RC_minus        = KEY_VOLUMEDOWN,
+	RC_plus         = KEY_VOLUMEUP,
+
+	RC_standby	= KEY_POWER,
+
+	RC_home         = KEY_HOME,  // most receivers use this for EXIT
+	RC_exit         = KEY_EXIT,  // but some use this
+	RC_setup	= KEY_MENU,
+
+	RC_page_up	= KEY_PAGEUP,
+	RC_page_down	= KEY_PAGEDOWN,
+
+	RC_ok		= KEY_OK,
+
+	RC_red		= KEY_RED,
+	RC_green	= KEY_GREEN,
+	RC_yellow	= KEY_YELLOW,
+	RC_blue		= KEY_BLUE,
 
 	RC_audio	= KEY_AUDIO,		/* 0x188 */
 	RC_video	= KEY_VIDEO,		/* 0x189 */
-			
+
 	RC_text		= KEY_TEXT,		/* 0x184 */
-	RC_info		= KEY_INFO,		/* 0x166 */			
+	RC_info		= KEY_INFO,		/* 0x166 */
 	RC_epg		= KEY_EPG,		/* 0x16d */
 	RC_recall 	= KEY_BACK,		/* 0x9E */
 	RC_favorites	= KEY_FAVORITES,	/* 0x16c */
 	RC_sat		= KEY_SAT,		/* 0x17d */
-			
+
 	RC_record	= KEY_RECORD,		/* 0xA7 */
 	RC_play		= KEY_PLAY,		/* 0xCF */
 	RC_pause	= KEY_PAUSE,		/* 0x77 */
 	RC_forward	= KEY_FASTFORWARD,	/* 0xD0 */
 	RC_rewind	= KEY_REWIND,		/* 0xA8 */
 	RC_stop		= KEY_STOP,		/* 0x80 */
-			
+
 	RC_timeshift	= KEY_TIME,		/* 0x167 */
-						
+
 	RC_mode		= KEY_MODE,		/* 0x175 */
 
 	RC_next		= 0xFFFFFFF0,
@@ -206,11 +207,11 @@
 
 	/* added from cuberevo3000hd so fix it please */
 	RC_music	= KEY_MUSIC,
-	RC_picture	= KEY_ARCHIVE,			
-			
+	RC_picture	= KEY_ARCHIVE,
+
 	RC_loop		= KEY_REPEAT,
 	RC_slow		= KEY_SLOW,
-			
+
 	RC_dvbsub	= KEY_DVBSUB,
 
 	RC_pip		= KEY_PIP,
@@ -227,7 +228,7 @@
 	RC_f2		= KEY_F2,
 	RC_f3		= KEY_F3,
 	RC_f4		= KEY_F4,
-			
+
 	//RC_aspect	= 0x40,
 
 	/* frontpanel */
@@ -288,7 +289,7 @@
 		int fd_keyb;
 		int fd_event;
 		int fd_max;
-		
+
 		__u16 rc_last_key;
 
 		void open();
@@ -299,7 +300,7 @@
 
 		int checkTimers();
 
-	public:		
+	public:
 		CConfigFile	configfile;
 
 		neutrino_msg_t key_0;
@@ -312,26 +313,27 @@
 		neutrino_msg_t key_7;
 		neutrino_msg_t key_8;
 		neutrino_msg_t key_9;
-			
+
 		neutrino_msg_t key_up;
 		neutrino_msg_t key_left;
 		neutrino_msg_t key_right;
 		neutrino_msg_t key_down;
-			
+
 		neutrino_msg_t key_spkr;
-						
+
 		neutrino_msg_t key_minus;
-		neutrino_msg_t key_plus;			
+		neutrino_msg_t key_plus;
 
 		neutrino_msg_t key_standby;
 		neutrino_msg_t key_home;
-		neutrino_msg_t key_setup;				
-			
+		neutrino_msg_t key_exit;
+		neutrino_msg_t key_setup;
+
 		neutrino_msg_t key_page_up;
-		neutrino_msg_t key_page_down;			
-			
+		neutrino_msg_t key_page_down;
+
 		neutrino_msg_t key_ok;
-			
+
 		neutrino_msg_t key_red;
 		neutrino_msg_t key_green;
 		neutrino_msg_t key_yellow;
@@ -339,39 +341,39 @@
 
 		neutrino_msg_t key_audio;
 		neutrino_msg_t key_video;
-			
+
 		neutrino_msg_t key_text;
 
-		neutrino_msg_t key_info;				
-			
+		neutrino_msg_t key_info;
+
 		neutrino_msg_t key_epg;
-			
-		neutrino_msg_t key_recall;		
+
+		neutrino_msg_t key_recall;
 
 		neutrino_msg_t key_favorites;
 
 		neutrino_msg_t key_sat;
-			
+
 		neutrino_msg_t key_record;
 		neutrino_msg_t key_play;
 		neutrino_msg_t key_pause;
 		neutrino_msg_t key_forward;
 		neutrino_msg_t key_rewind;
 		neutrino_msg_t key_stop;
-			
+
 		neutrino_msg_t key_timeshift;
-						
-		neutrino_msg_t key_mode;			
+
+		neutrino_msg_t key_mode;
 
 		neutrino_msg_t key_next;
-		neutrino_msg_t key_prev;			
+		neutrino_msg_t key_prev;
 
 		//
 		neutrino_msg_t key_music;
-		neutrino_msg_t key_picture;	
+		neutrino_msg_t key_picture;
 		neutrino_msg_t key_repeat;
 		neutrino_msg_t key_slow;
-			
+
 		neutrino_msg_t key_dvbsub;
 
 		neutrino_msg_t key_pip;
@@ -379,17 +381,17 @@
 		neutrino_msg_t key_pipswap;
 		neutrino_msg_t key_pipsubch;
 
-		neutrino_msg_t key_net;	
+		neutrino_msg_t key_net;
 		neutrino_msg_t key_bookmark;
 		neutrino_msg_t key_multifeed;
-					
+
 		neutrino_msg_t key_f1;
 		neutrino_msg_t key_f2;
 		neutrino_msg_t key_f3;
 		neutrino_msg_t key_f4;
-		
+
 		//neutrino_msg_t key_aspect;
-			
+
 		neutrino_msg_t key_vfdup;
 		neutrino_msg_t key_vfddown;
 		neutrino_msg_t key_vfdright;
@@ -398,18 +400,18 @@
 		neutrino_msg_t key_vfdmenu;
 		neutrino_msg_t key_vfdexit;
 		neutrino_msg_t key_vfdok;
-		
+
 		bool loadKeyMap(const char * const fileName);
 		bool saveKeyMap(const char * const fileName);
-		
+
 		void stopInput();
 		void restartInput();
 
 		uint64_t repeat_block;
 		uint64_t repeat_block_generic;
-		
+
 		void setRepeat(unsigned int delay, unsigned int period);
-		
+
 		CRCInput();      //constructor - opens rc-device and starts needed threads
 		~CRCInput();     //destructor - closes rc-device
 
@@ -471,7 +473,7 @@
 		* @return the last key calculated by #handleMsg(neutrino_msg_t)
 		*/
 		unsigned char getOldKey() const;
-		
+
 		/**
 		* Returns time of last key push.
 		* resolution: usecs
--- neutrino-hd2.org/src/driver/rcinput.cpp
+++ neutrino-hd2/src/driver/rcinput.cpp
@@ -115,6 +115,7 @@
 			
 #if defined (__sh__)
 	key_home = configfile.getInt32("key_home", KEY_HOME);
+	key_exit = configfile.getInt32("key_exit", KEY_EXIT);
 #else
 	key_home = configfile.getInt32("key_home", 0xAE);
 #endif			
@@ -272,6 +273,7 @@
 	configfile.setInt32("key_standby", key_standby);
 			
 	configfile.setInt32("key_home", key_home);
+	configfile.setInt32("key_exit", key_exit);
 			
 	configfile.setInt32("key_setup", key_setup);
 				
@@ -557,7 +559,7 @@
 	{
 		g_RCInput->getMsgAbsoluteTimeout( &msg, &data, &timeoutEnd );
 
-		if ( ( msg == RC_timeout ) || ( msg == RC_home ) || ( msg == RC_ok ) )
+		if ( ( msg == RC_timeout ) || ( msg == RC_home ) || ( msg == RC_exit ) || ( msg == RC_ok ) )
 		{
 			doLoop = false;
 		}
@@ -1653,6 +1655,9 @@
 		case RC_home:
 			return "RC_home";
 
+		case RC_exit:
+			return "RC_home";
+
 		case RC_setup:
 			return "RC_setup";
 
@@ -1879,6 +1884,7 @@
 	else if (code == key_down) return RC_down;
 	else if (code == key_right) return RC_right;
 	else if (code == key_home) return RC_home;
+	else if (code == key_exit) return RC_home;
 			
 	/* special */
 	else if (code == key_recall) return RC_recall;
--- nhd2-exp.org/src/neutrino.h
+++ nhd2-exp/src/neutrino.h
@@ -213,13 +213,13 @@
 		void lockPlayBack(void);
 		void unlockPlayBack(void);
 		
-		// 0 - restart 
-		// 1 - halt
-		// 2 - reboot
+		// 0 - halt
+		// 1 - reboot
+		// 2 - restart 
 		enum {
-			RESTART = 0,
-			SHUTDOWN,
-			REBOOT
+			SHUTDOWN = 0,
+			REBOOT,
+			RESTART
 		};
 		
 		void ExitRun(int retcode = SHUTDOWN);
#--- neutrino-hd2.org/src/neutrino.cpp
#+++ neutrino-hd2.git/nhd2-exp/src/neutrino.cpp
#@@ -464,11 +464,11 @@
# 	}
# 
# 	// video
#-#ifdef __sh__	
#-	g_settings.video_Mode = configfile.getInt32("video_Mode", VIDEO_STD_PAL);
#-#else
#+//#ifdef __sh__	
#+//	g_settings.video_Mode = configfile.getInt32("video_Mode", VIDEO_STD_PAL);
#+//#else
# 	g_settings.video_Mode = configfile.getInt32("video_Mode", VIDEO_STD_720P50);
#-#endif
#+//#endif
# 	prev_video_Mode = g_settings.video_Mode;
# 	
# 	//analog mode
--- nhd2-exp.org/src/driver/vfd.h
+++ nhd2-exp/src/driver/vfd.h
@@ -37,11 +37,31 @@
 #include <cs_vfd.h>
 #endif
 
+// VFD/LED display width
+#if defined(PLATFORM_SPARK7162) \
+ || defined(BOXMODEL_HS9510) \
+ || defined(BOXMODEL_HS7420) \
+ || defined(BOXMODEL_HS7429)
+#define VFD_LENGTH 8
+#elif defined(BOXMODEL_FS9000) \
+ ||   defined(BOXMODEL_HS8200)
+#define VFD_LENGTH 12
+#elif defined(BOXMODEL_HS7119) \
+ || defined(BOXMODEL_HS7810A) \
+ || defined(BOXMODEL_HS7819)
+#define VFD_LENGTH 4
+#elif defined(BOXMODEL_HS7110)
+#define VFD_LENGTH 0
+#elif defined(BOXMODEL_ADB_BOX)
+#define VFD_LENGTH 15
+#else
+#define VFD_LENGTH 16
+#endif
 
 #if defined(PLATFORM_SPARK7162)
-/* SAB Triple VFD Icons								*/
-/* taken from aotom_main.h, with these numbers the Icons on Spark7162		*/
-/* will work right ( hopefully all Models )					*/
+/* SAB Triple VFD Icons                                               */
+/* taken from aotom_main.h, with these numbers the Icons on Spark7162 */
+/* will work right ( hopefully all Models )                           */
 typedef enum {
 //----------------------------------11G-------------------------------------
 	VFD_SPARK_PLAY_FASTBACKWARD = 1,		//11*16+1,
@@ -92,7 +112,7 @@
 	VFD_SPARK_DOT1 = 44,
 	VFD_SPARK_CAB = 45,	
 //----------------------------------end-------------------------------------
-	SPARK_ICON_ALL = 46, 		/* with this number the aotom driver set all icons on (1) or off (0) */
+	SPARK_ICON_ALL = 46,  /* with this number the aotom driver set all icons on (1) or off (0) */
 	VFD_ICON_MAX
 } spark7162_vfd_icon;
 
@@ -131,9 +151,7 @@
 	VFD_ICON_STANDBY	= VFD_SPARK_CYCLE	
 } vfd_icon;
 
-#endif //spark7162
-
-#if defined(PLATFORM_KATHREIN)
+#elif defined(PLATFORM_KATHREIN)
 typedef enum
 {
 	vfd_910_usb = 1,
@@ -177,11 +195,361 @@
 	VFD_ICON_HDD 		= vfd_910_hdd,	
 	VFD_ICON_CLOCK		= vfd_910_clock
 } vfd_icon;
-#endif //ufs910, ufs913
-
-#if !defined(PLATFORM_KATHREIN) && !defined(PLATFORM_SPARK7162) && !defined (PLATFORM_COOLSTREAM)
-// duckbox
-// token from micom
+
+#elif defined(BOXMODEL_FS9000)
+typedef enum
+{
+	HDBOX_ICON_USB = 0x1,  // 01
+	HDBOX_ICON_STANDBY,    // 02
+	HDBOX_ICON_SAT,        // 03
+	HDBOX_ICON_REC,        // 04
+	HDBOX_ICON_TIMESHIFT,  // 05
+	HDBOX_ICON_TIMER,      // 06
+	HDBOX_ICON_HD,         // 07
+	HDBOX_ICON_SCRAMBLED,  // 08
+	HDBOX_ICON_DOLBY,      // 09
+	HDBOX_ICON_MUTE,       // 10
+	HDBOX_ICON_TUNER1,     // 11
+	HDBOX_ICON_TUNER2,     // 12
+	HDBOX_ICON_MP3,        // 13
+	HDBOX_ICON_REPEAT,     // 14
+	HDBOX_ICON_PLAY,       // 15
+	HDBOX_ICON_TER,        // 16
+	HDBOX_ICON_FILE,       // 17
+	HDBOX_ICON_480i,       // 18
+	HDBOX_ICON_480p,       // 19
+	HDBOX_ICON_576i,       // 20
+	HDBOX_ICON_576p,       // 21
+	HDBOX_ICON_720p,       // 22
+	HDBOX_ICON_1080i,      // 23
+	HDBOX_ICON_1080p,      // 24
+	HDBOX_ICON_Circ0,      // 25
+	HDBOX_ICON_Circ1,      // 26
+	HDBOX_ICON_Circ2,      // 27
+	HDBOX_ICON_Circ3,      // 28
+	HDBOX_ICON_Circ4,      // 29
+	HDBOX_ICON_Circ5,      // 30
+	HDBOX_ICON_Circ6,      // 31
+	HDBOX_ICON_Circ7,      // 32
+	HDBOX_ICON_Circ8,      // 33
+	HDBOX_ICON_COLON1,     // 34
+	HDBOX_ICON_COLON2,     // 35
+	HDBOX_ICON_COLON3,     // 36
+	HDBOX_ICON_COLON4,     // 37
+	HDBOX_ICON_TV,         // 38
+	HDBOX_ICON_RADIO,      // 39
+	ICON_ALL               // 40 new nuvoton will set/clear all icons with this number
+} fs9000_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= HDBOX_ICON_MUTE,
+	VFD_ICON_DOLBY		= HDBOX_ICON_DOLBY,
+	VFD_ICON_POWER		= HDBOX_ICON_STANDBY,
+	VFD_ICON_TIMESHIFT	= HDBOX_ICON_TIMESHIFT,
+	VFD_ICON_TV		= HDBOX_ICON_TV,
+	VFD_ICON_RADIO		= HDBOX_ICON_RADIO,
+	VFD_ICON_HD		= HDBOX_ICON_HD,
+	VFD_ICON_1080P		= HDBOX_ICON_1080p,
+	VFD_ICON_1080I		= HDBOX_ICON_1080i,
+	VFD_ICON_720P		= HDBOX_ICON_720p,
+	VFD_ICON_480P		= HDBOX_ICON_480p,
+	VFD_ICON_480I		= HDBOX_ICON_480i,
+	VFD_ICON_USB		= HDBOX_ICON_USB,
+	VFD_ICON_MP3		= HDBOX_ICON_MP3,
+	VFD_ICON_PLAY		= HDBOX_ICON_PLAY,
+	VFD_ICON_PAUSE		= HDBOX_ICON_TER,
+	VFD_ICON_LOCK 		= HDBOX_ICON_SCRAMBLED,
+	VFD_ICON_CLOCK		= HDBOX_ICON_TIMER,
+	VFD_ICON_STANDBY	= HDBOX_ICON_STANDBY
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS9510)
+typedef enum //HS9510 icon numbers and their names
+{
+	HS9510_ICON_DOLBY = 0x1,  // 01
+	HS9510_ICON_DTS,          // 02
+	HS9510_ICON_VIDEO,        // 03
+	HS9510_ICON_AUDIO,        // 04
+	HS9510_ICON_LINK,         // 05
+	HS9510_ICON_HDD,          // 06
+	HS9510_ICON_DISC,         // 07
+	HS9510_ICON_DVB,          // 08
+	HS9510_ICON_DVD,          // 09
+	HS9510_ICON_TIMER,        // 10
+	HS9510_ICON_TIME,         // 11
+	HS9510_ICON_CARD,         // 12
+	HS9510_ICON_1,            // 13
+	HS9510_ICON_2,            // 14
+	HS9510_ICON_KEY,          // 15
+	HS9510_ICON_16_9,         // 16
+	HS9510_ICON_USB,          // 17
+	HS9510_ICON_CRYPTED,      // 18
+	HS9510_ICON_PLAY,         // 19
+	HS9510_ICON_REWIND,       // 20
+	HS9510_ICON_PAUSE,        // 21
+	HS9510_ICON_FF,           // 22
+	HS9510_ICON_NONE,         // 23
+	HS9510_ICON_REC,          // 24
+	HS9510_ICON_ARROW,        // 25
+	HS9510_ICON_COLON1,       // 26
+	HS9510_ICON_COLON2,       // 27
+	HS9510_ICON_COLON3,       // 28
+	ICON_ALL                  // 29 new nuvoton will set/clear all icons with this number
+} hs9510_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= HS9510_ICON_TIME,
+	VFD_ICON_DOLBY		= HS9510_ICON_DOLBY,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= HS9510_ICON_REC,
+	VFD_ICON_TV		= HS9510_ICON_VIDEO,
+	VFD_ICON_RADIO		= HS9510_ICON_AUDIO,
+	VFD_ICON_HD		= HS9510_ICON_16_9,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= HS9510_ICON_USB,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= HS9510_ICON_PLAY,
+	VFD_ICON_PAUSE		= HS9510_ICON_PAUSE,
+	VFD_ICON_LOCK 		= HS9510_ICON_CRYPTED,
+	VFD_ICON_CLOCK		= HS9510_ICON_TIMER,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS8200)
+typedef enum //HS8200 icon numbers and their names
+{
+	HS8200_ICON_STANDBY = 1, // 01
+	HS8200_ICON_REC,         // 02
+	HS8200_ICON_TIMESHIFT,   // 03
+	HS8200_ICON_TIMER,       // 04
+	HS8200_ICON_HD,          // 05
+	HS8200_ICON_USB,         // 06
+	HS8200_ICON_SCRAMBLED,   // 07
+	HS8200_ICON_DOLBY,       // 08
+	HS8200_ICON_MUTE,        // 09
+	HS8200_ICON_TUNER1,      // 10
+	HS8200_ICON_TUNER2,      // 11
+	HS8200_ICON_MP3,         // 12
+	HS8200_ICON_REPEAT,      // 13
+	HS8200_ICON_PLAY,        // 14
+	HS8200_ICON_STOP,        // 15
+	HS8200_ICON_PAUSE,       // 16
+	HS8200_ICON_REWIND,      // 17
+	HS8200_ICON_FF,          // 18
+	HS8200_ICON_STEP_BACK,   // 19
+	HS8200_ICON_STEP_FWD,    // 20
+	HS8200_ICON_TV,          // 21
+	HS8200_ICON_RADIO,       // 22
+	ICON_ALL                 // 23 new nuvoton will set/clear all icons with this number
+} hs8200_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= HS8200_ICON_MUTE,
+	VFD_ICON_DOLBY		= HS8200_ICON_DOLBY,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= HS8200_ICON_TIMESHIFT,
+	VFD_ICON_TV		= HS8200_ICON_TV,
+	VFD_ICON_RADIO		= HS8200_ICON_RADIO,
+	VFD_ICON_HD		= HS8200_ICON_HD,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= HS8200_ICON_USB,
+	VFD_ICON_MP3		= HS8200_ICON_MP3,
+	VFD_ICON_PLAY		= HS8200_ICON_PLAY,
+	VFD_ICON_PAUSE		= HS8200_ICON_PAUSE,
+	VFD_ICON_LOCK 		= HS8200_ICON_SCRAMBLED,
+	VFD_ICON_CLOCK		= HS8200_ICON_TIMER,
+	VFD_ICON_STANDBY	= HS8200_ICON_STANDBY
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS7420) \
+ ||   defined(BOXMODEL_HS7429)
+typedef enum //HS742X icon numbers and their names
+{
+	HS742X_ICON_DOT = 1,      // 01
+	HS742X_ICON_COLON1,       // 02
+	HS742X_ICON_COLON2,       // 03
+	HS742X_ICON_COLON3,       // 04
+	ICON_ALL                  // 05 new nuvoton will set/clear all icons with this number
+} hs742x_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= 0,
+	VFD_ICON_DOLBY		= 0,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= 0,
+	VFD_ICON_TV		= 0,
+	VFD_ICON_RADIO		= 0,
+	VFD_ICON_HD		= 0,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= 0,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= 0,
+	VFD_ICON_PAUSE		= 0,
+	VFD_ICON_LOCK 		= 0,
+	VFD_ICON_CLOCK		= 0,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS7119)
+typedef enum //HS7119 icon numbers and their names
+{
+	HS7119_ICON_COLON = 1,    // 01
+	ICON_ALL                  // 02 new nuvoton will set/clear all icons with this number
+} hs7119_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= 0,
+	VFD_ICON_DOLBY		= 0,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= 0,
+	VFD_ICON_TV		= 0,
+	VFD_ICON_RADIO		= 0,
+	VFD_ICON_HD		= 0,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= 0,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= 0,
+	VFD_ICON_PAUSE		= 0,
+	VFD_ICON_LOCK 		= 0,
+	VFD_ICON_CLOCK		= 0,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS7810A) \
+ ||   defined(BOXMODEL_HS7819)
+typedef enum //HS7810A & HS7819 icon numbers and their names
+{
+	HS7810A_ICON_COLON = 1,   // 01
+	HS7810A_ICON_PERIOD1,     // 02
+	HS7810A_ICON_PERIOD2,     // 03
+	HS7810A_ICON_PERIOD3,     // 04
+	ICON_ALL                  // 05 new nuvoton will set/clear all icons with this number
+} hs7810a_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= 0,
+	VFD_ICON_DOLBY		= 0,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= 0,
+	VFD_ICON_TV		= 0,
+	VFD_ICON_RADIO		= 0,
+	VFD_ICON_HD		= 0,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= 0,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= 0,
+	VFD_ICON_PAUSE		= 0,
+	VFD_ICON_LOCK 		= 0,
+	VFD_ICON_CLOCK		= 0,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS7110)
+typedef enum
+{
+	ICON_ALL		= 0,
+	VFD_ICON_MUTE		= 0,
+	VFD_ICON_DOLBY		= 0,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= 0,
+	VFD_ICON_TV		= 0,
+	VFD_ICON_RADIO		= 0,
+	VFD_ICON_HD		= 0,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= 0,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= 0,
+	VFD_ICON_PAUSE		= 0,
+	VFD_ICON_LOCK 		= 0,
+	VFD_ICON_CLOCK		= 0,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_ADB_BOX)
+typedef enum //ADB ITI-5800SX icon numbers and their names
+{
+	ADB_ICON_MIN,       // 00
+	ADB_ICON_REC,       // 01
+	ADB_ICON_TIMESHIFT, // 02
+	ADB_ICON_TIMER,     // 03
+	ADB_ICON_HD,        // 04
+	ADB_ICON_USB,       // 05
+	ADB_ICON_SCRAMBLED, // 06
+	ADB_ICON_DOLBY,     // 07
+	ADB_ICON_MUTE,      // 08
+	ADB_ICON_TUNER1,    // 09
+	ADB_ICON_TUNER2,    // 10
+	ADB_ICON_MP3,       // 11
+	ADB_ICON_REPEAT,    // 12
+	ADB_ICON_PLAY,      // 13
+	ADB_ICON_STOP,      // 14
+	ADB_ICON_PAUSE,     // 15
+	ADB_ICON_REWIND,    // 16
+	ADB_ICON_FF,        // 17
+	ADB_ICON_STEP_BACK, // 18
+	ADB_ICON_STEP_FWD,  // 19
+	ADB_ICON_TV,        // 20
+	ADB_ICON_RADIO,     // 21
+	ADB_ICON_MAX,       // 22
+	ADB_ICON_SPINNER    // 23
+} adb_box_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= ADB_ICON_MUTE,
+	VFD_ICON_DOLBY		= ADB_ICON_DOLBY,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= ADB_ICON_TIMESHIFT,
+	VFD_ICON_TV		= ADB_ICON_TV,
+	VFD_ICON_RADIO		= ADB_ICON_RADIO,
+	VFD_ICON_HD		= ADB_ICON_HD,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= ADB_ICON_USB,
+	VFD_ICON_MP3		= ADB_ICON_MP3,
+	VFD_ICON_PLAY		= ADB_ICON_PLAY,
+	VFD_ICON_PAUSE		= ADB_ICON_PAUSE,
+	VFD_ICON_LOCK 		= ADB_ICON_SCRAMBLED,
+	VFD_ICON_CLOCK		= ADB_ICON_TIMER,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#else
+// generic duckbox
+// taken from micom
 enum {
 	ICON_MIN,             // 0x00
 	ICON_STANDBY,
@@ -212,7 +580,7 @@
 	ICON_RADIO,   
 	ICON_TV,      
 	ICON_PAUSE,   
-	ICON_MAX
+	ICON_ALL
 };
 
 // neutrino common
@@ -236,19 +604,24 @@
 	VFD_ICON_PAUSE		= ICON_PAUSE,
 	VFD_ICON_LOCK 		= ICON_SCRAMBLED
 } vfd_icon;
-#endif  //common
+#endif
 
 #if defined (__sh__)
 #define VFDBRIGHTNESS         0xc0425a03
-#define VFDPWRLED             0xc0425a04 /* added by zeroone, also used in fp_control/global.h ; set PowerLed Brightness on HDBOX*/
+#define VFDPWRLED             0xc0425a04 /* Obsolete, use VFDSETLED */
 #define VFDDRIVERINIT         0xc0425a08
 #define VFDICONDISPLAYONOFF   0xc0425a0a
 #define VFDDISPLAYWRITEONOFF  0xc0425a05
 #define VFDDISPLAYCHARS       0xc0425a00
 
+#define VFDSETRF              0xc0425af7
+#if !defined (BOXMODEL_ADB_BOX)
 #define VFDCLEARICONS	      0xc0425af6
-#define VFDSETRF              0xc0425af7
 #define VFDSETFAN             0xc0425af8
+#else
+#define VFDSETFAN             0xc0425af6
+#define VFDLEDBRIGHTNESS      0xc0425af8
+#endif
 #define VFDGETWAKEUPMODE      0xc0425af9
 #define VFDGETTIME            0xc0425afa
 #define VFDSETTIME            0xc0425afb
@@ -263,8 +636,9 @@
 #define VFDSETTIMEMODE        0xc0425b03
 #define VFDDISPLAYCLR	      0xc0425b00
 
-#if defined(PLATFORM_SPARK7162)
-/* structs are needed for sending icons etc. to aotom 				*/
+#if defined(PLATFORM_SPARK7162) \
+ || defined(PLATFORM_SPARK)
+/* structs are needed for sending icons etc. to aotom */
 struct set_mode_s {
 	int compat; /* 0 = compatibility mode to vfd driver; 1 = nuvoton mode */
 };
@@ -308,31 +682,38 @@
 		struct set_time_s time;
 	} u;
 };
-#elif defined (PLATFORM_SPARK)
-/* ugly: this is copied from frontcontroller utility, but the driver
- * does not seem to provide userspace headers... :-( */
-
-
-/* this setups the mode temporarily (for one ioctl)
- * to the desired mode. currently the "normal" mode
- * is the compatible vfd mode
- */
-struct set_mode_s {
-	int compat; /* 0 = compatibility mode to vfd driver; 1 = nuvoton mode */
-};
-
-struct set_brightness_s {
+
+#elif defined(BOXMODEL_FS9000) \
+   || defined(BOXMODEL_HS9510) \
+   || defined(BOXMODEL_HS8200) \
+   || defined(BOXMODEL_HS7110) \
+   || defined(BOXMODEL_HS7420) \
+   || defined(BOXMODEL_HS7810A) \
+   || defined(BOXMODEL_HS7119) \
+   || defined(BOXMODEL_HS7429) \
+   || defined(BOXMODEL_HS7819)
+//#elif defined(PLATFORM_FORTIS)
+/* structs are needed for sending icons etc. to nuvoton */
+struct set_brightness_s
+{
 	int level;
 };
 
-struct set_icon_s {
+struct set_icon_s
+{
 	int icon_nr;
 	int on;
 };
 
-struct set_led_s {
+struct set_led_s
+{
 	int led_nr;
-	int on;
+	int level;
+};
+
+struct set_light_s
+{
+	int onoff;
 };
 
 /* time must be given as follows:
@@ -341,38 +722,49 @@
  * time[3] = min
  * time[4] = sec
  */
-struct set_standby_s {
+struct set_standby_s
+{
 	char time[5];
 };
 
-struct set_time_s {
+struct set_time_s
+{
 	char time[5];
 };
 
-struct aotom_ioctl_data {
+struct set_timeformat_s
+{
+	int format;
+};
+
+/* This will set the mode temporarily (for one ioctl)
+ * to the desired mode. Currently the "normal" mode
+ * is the compatible vfd mode
+ */
+struct set_mode_s
+{
+	int compat; /* 0 = compatibility mode to vfd driver; 1 = nuvoton mode */
+};
+
+
+struct nuvoton_ioctl_data
+{
 	union
 	{
 		struct set_icon_s icon;
 		struct set_led_s led;
 		struct set_brightness_s brightness;
+		struct set_light_s light;
 		struct set_mode_s mode;
 		struct set_standby_s standby;
 		struct set_time_s time;
+		struct set_timeformat_s timeformat;
 	} u;
 };
-
-/* a strange way of defining ioctls... but anyway... */
-#define VFDGETTIME      0xc0425afa
-#define VFDSETTIME      0xc0425afb
-#define VFDSTANDBY      0xc0425afc
-#define VFDSETLED       0xc0425afe
-#define VFDDISPLAYCHARS 0xc0425a00
-#define VFDDISPLAYCLR   0xc0425b00
-#define VFDSETMODE      0xc0425aff
-#endif //Spark7162
-
-
-struct vfd_ioctl_data {
+#endif
+
+struct vfd_ioctl_data
+{
 	unsigned char start_address;
 	unsigned char data[64];
 	unsigned char length;
--- nhd2-exp.org/src/driver/vfd.cpp
+++ nhd2-exp/src/driver/vfd.cpp
@@ -47,15 +47,30 @@
 
 
 #if defined (__sh__)
-#if defined (PLATFORM_SPARK7162)
+  #if defined (PLATFORM_SPARK7162)
 static struct aotom_ioctl_data aotom_data;
-#endif
-
-#if defined (PLATFORM_KATHREIN) || defined (PLATFORM_SPARK7162)
+  #elif defined(BOXMODEL_FS9000) \
+     || defined(BOXMODEL_HS9510) \
+     || defined(BOXMODEL_HS8200) \
+     || defined(BOXMODEL_HS7110) \
+     || defined(BOXMODEL_HS7420) \
+     || defined(BOXMODEL_HS7810A) \
+     || defined(BOXMODEL_HS7119) \
+     || defined(BOXMODEL_HS7429) \
+     || defined(BOXMODEL_HS7819)
+static struct nuvoton_ioctl_data nuvoton_data;
+  #endif
+
+  #if defined(PLATFORM_KATHREIN) \
+   || defined(PLATFORM_SPARK7162) \
+   || defined(BOXMODEL_FS9000) \
+   || defined(BOXMODEL_HS9510) \
+   || defined(BOXMODEL_HS8200) \
+   || defined(BOXMODEL_ADB_BOX)
 static bool usb_icon = false;
 static bool timer_icon = false;
 static bool hdd_icon = false;
-#endif
+  #endif
 
 //konfetti: let us share the device with evremote and fp_control
 //it does currently not support more than one user (see e.g. micom)
@@ -69,9 +84,11 @@
 		if(fd < 0)
 		{
 			printf("failed to open vfd\n");
+#if defined (BOXMODEL_TF7700)
 			fd = open("/dev/fplarge", O_RDWR);
 			if (fd < 0)
 			    printf("failed to open fplarge\n");
+#endif
 		}
 		else
 			blocked = true;
@@ -88,7 +105,7 @@
 	
 	fd = -1;
 }
-#endif
+#endif //__sh__
 
 // default: has_lcd:1, is4digits:0, has_led:0
 // constructor
@@ -208,7 +225,11 @@
 	}
 	else
 		setPower(1);
-#endif	
+#elif defined (BOXMODEL_HS9510)
+	ShowIcon((vfd_icon)HS9510_ICON_COLON2, false);
+#elif defined(BOXMODEL_HS7420) || defined(BOXMODEL_HS7429)
+	ShowIcon((vfd_icon)HS742X_ICON_COLON1, false);
+#endif
 }
 
 void * CVFD::TimeThread(void *)
@@ -245,7 +266,8 @@
 	}
 	
 	// set led color
-#if defined (PLATFORM_GIGABLUE)
+#if defined (PLATFORM_GIGABLUE) \
+ || defined (BOXMODEL_ADB_BOX)
 	vfd_led(g_settings.lcd_ledcolor);  //0:off, 1:blue, 2:red, 3:purple
 #elif defined (PLATFORM_VENTON)
 	vfd_symbol_network(0);
@@ -277,15 +299,18 @@
         struct vfd_ioctl_data data;
 	data.start_address = dimm;
 	
-	if(dimm < 1)
-		dimm = 1;
+	if (dimm < 0)
+	{
+		dimm = 0;
+	}
 	brightness = dimm;
 	
 	openDevice();
 	
-	if( ioctl(fd, VFDBRIGHTNESS, &data) < 0)  
+	if (ioctl(fd, VFDBRIGHTNESS, &data) < 0)  
+	{
 		perror("VFDBRIGHTNESS");
-	
+	}
 	closeDevice();
 #elif defined (PLATFORM_COOLSTREAM)
 	int ret = ioctl(fd, IOC_VFD_SET_BRIGHT, dimm);
@@ -342,14 +367,23 @@
 			{
 				hour = t->tm_hour;
 				minute = t->tm_min;
-#if defined (PLATFORM_KATHREIN)							/* time and date at kathrein because 16 character vfd	*/
+#if defined(PLATFORM_KATHREIN)  /* time and date at kathrein because 16 character vfd */
 				strftime(timestr, 20, "%H:%M - %d.%m.%y", t);
-#elif !defined(PLATFORM_SPARK7162) && !defined (PLATFORM_KATHREIN)		/* no time at spark7162 because clock integrated	*/
+#elif defined(BOXMODEL_HS9510)  /* no colon on hs9510: it is an icon */
+				ShowIcon((vfd_icon)HS9510_ICON_COLON2, true);
+ 				strftime(timestr, 20, "%H%M", t);
+#elif defined(BOXMODEL_HS7420) || defined(BOXMODEL_HS7429)  /* no colon on HS742X: it is an icon */
+				ShowIcon((vfd_icon)HS742X_ICON_COLON1, true);
+ 				strftime(timestr, 20, "%H%M", t);
+#elif defined(BOXMODEL_HS7810A) || defined(BOXMODEL_HS7119) || defined (BOXMODEL)  /* do not scroll on these models */
+ 				strftime(timestr, 20, "%H:%M", t);
+
+#elif !defined(PLATFORM_SPARK7162)  /* no time at spark7162 because clock integrated */
  				strftime(timestr, 20, "%H:%M", t);
 #endif				
 				ShowText(timestr);
 			}
-		} 
+		}
 	}
 
 	if (CNeutrinoApp::getInstance()->recordingstatus) 
@@ -408,25 +442,106 @@
 	switch(m) 
 	{
 		case AUDIO_MODE_PLAY:
+		{
 			ShowIcon(VFD_ICON_PLAY, true);
 			ShowIcon(VFD_ICON_PAUSE, false);
-			break;
-			
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, false);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, false);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, false);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, false);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, false);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, false);
+			ShowIcon((vfd_icon)ADB_ICON_FF, false);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, false);
+#endif
+			break;
+		}
 		case AUDIO_MODE_STOP:
+		{
 			ShowIcon(VFD_ICON_PLAY, false);
 			ShowIcon(VFD_ICON_PAUSE, false);
-			break;
-			
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, false);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, false);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, false);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, false);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, false);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, false);
+			ShowIcon((vfd_icon)ADB_ICON_FF, false);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, false);
+#endif
+			break;
+		}
 		case AUDIO_MODE_PAUSE:
+		{
 			ShowIcon(VFD_ICON_PLAY, false);
 			ShowIcon(VFD_ICON_PAUSE, true);
-			break;
-			
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, false);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, false);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, true);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, false);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, false);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, false);
+			ShowIcon((vfd_icon)ADB_ICON_FF, false);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, true);
+#endif
+			break;
+		}
 		case AUDIO_MODE_FF:
-			break;
-			
+		{
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, true);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, true);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, false);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, false);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, true);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, false);
+			ShowIcon((vfd_icon)ADB_ICON_FF, true);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, false);
+#endif
+			break;
+		}
 		case AUDIO_MODE_REV:
-			break;
+		{
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, true);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, false);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, true);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, false);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, false);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, true);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, false);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, true);
+			ShowIcon((vfd_icon)ADB_ICON_FF, false);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, false);
+#endif
+			break;
+		}
 	}
 
 	wake_up();
@@ -450,34 +565,41 @@
 
 	switch (m) 
 	{
-		case MODE_TVRADIO:	
+		case MODE_TVRADIO:
+		{	
 			showServicename(servicename);
 #if !defined(PLATFORM_SPARK7162)			
 			ShowIcon(VFD_ICON_MP3, false);	        // NOTE: @dbo  //ICON_MP3 and ICON_DOLBY switched in infoviewer 
 #endif			
 	
-#if defined (PLATFORM_KATHREIN)
+#if defined(PLATFORM_KATHREIN) || defined(BOXMODEL_HS9510)
 			ShowIcon(VFD_ICON_USB, usb_icon);	
 			ShowIcon(VFD_ICON_HDD, hdd_icon);	
 #elif defined(PLATFORM_SPARK7162)
 			ShowIcon(VFD_ICON_USB, usb_icon);	
 			ShowDiskLevel();
 			ShowIcon(VFD_ICON_STANDBY, false);	
-#endif
+#elif defined(BOXMODEL_FS9000) || defined(BOXMODEL_HS8200)
+			ShowIcon(VFD_ICON_USB, usb_icon);	
+			ShowIcon(VFD_ICON_STANDBY, false);	
 			showclock = true;
+#elif defined(BOX_MODEL_ADB_BOX)
+			ShowIcon(VFD_ICON_USB, usb_icon);	
+#endif
 			//showTime();      /* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */			
 			break;
-
+		}
 		case MODE_AUDIO:
 		{
-#if defined(PLATFORM_SPARK7162)
+#if defined(PLATFORM_SPARK7162) \
+ || defined(BOXMODEL_ADB_BOX)
 			ShowIcon(VFD_ICON_AC3, false);			
 #endif		  
 			ShowIcon(VFD_ICON_MP3, true);			
 			ShowIcon(VFD_ICON_TV, false);			
 			showAudioPlayMode(AUDIO_MODE_STOP);			
 			showclock = true;
-#if !defined (PLATFORM_COOLSTREAM)			
+#if !defined(PLATFORM_COOLSTREAM)			
 			ShowIcon(VFD_ICON_LOCK, false);
 #endif			
 			ShowIcon(VFD_ICON_HD, false);
@@ -485,21 +607,23 @@
 			//showTime();      /* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */
 			break;
 		}
-
 		case MODE_SCART:	  
+		{
 			ShowIcon(VFD_ICON_TV, false);	
 			showclock = true;
 			//showTime();      /* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */
 			break;
-
+		}
 		case MODE_MENU_UTF8:
+		{
 			ShowIcon(VFD_ICON_TV, false);			
 			ShowIcon(VFD_ICON_HD, false);
 			ShowIcon(VFD_ICON_DOLBY, false);
 			showclock = false;
 			break;
-
+		}
 		case MODE_SHUTDOWN:
+		{
 			//Clear();
 			/* clear all symbols */
 			ClearIcons();
@@ -508,8 +632,9 @@
 #endif			
 			showclock = false;
 			break;
-
+		}
 		case MODE_STANDBY:
+		{
 			ShowIcon(VFD_ICON_TV, false);
 			ClearIcons();
 #if defined(PLATFORM_SPARK7162)
@@ -519,25 +644,29 @@
 			showTime(true);      	/* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */
 						/* "showTime()" clears the whole lcd in MODE_STANDBY */
 			break;
-		
+		}
 		case MODE_PIC:	  
+		{
 			ShowIcon(VFD_ICON_TV, false);			
 			ShowIcon(VFD_ICON_HD, false);
 			ShowIcon(VFD_ICON_DOLBY, false);
 			
 			showclock = false;
 			break;
-			
+		}
 		case MODE_MOVIE:  
+		{
 			ShowIcon(VFD_ICON_TV, false);			
 			showclock = false;
 			break;
-			
+		}
 		case MODE_WEBTV: 
+		{
 			showServicename(servicename);
 			ShowIcon(VFD_ICON_TV, false);			
 			showclock = false;
 			break;
+		}
 	}
 
 	wake_up();
@@ -587,13 +716,32 @@
 
 #if defined (__sh__)
 	struct vfd_ioctl_data data;
-	data.start_address = power;
+
+	data.start_address = 0;
+#if defined(BOXMODEL_FS9000) || defined(BOXMODEL_HS8200)
+	data.data[0] = power ? 0xf2 : 1;
+	data.data[4] = power * 2;
+#elif defined(BOXMODEL_HS9510) \
+   || defined(BOXMODEL_HS7420) \
+   || defined(BOXMODEL_HS7810A) \
+   || defined(BOXMODEL_HS7119) \
+   || defined(BOXMODEL_HS7429) \
+   || defined(BOXMODEL_HS7819)
+	data.data[0] = power ? 0 : 1;
+	data.data[4] = power;
+#elif defined(BOXMODEL_ADB_BOX)
+	data.data[0] = 1;  // power LED
+	data.data[4] = power ? 1 : 2;  // colour
+#else
+	data.data[4] = power;
+#endif
+	data.length = 5;
 	
 	openDevice();
-	
-	if( ioctl(fd, VFDPWRLED, &data) < 0)  
-		perror("VFDPWRLED");
-	
+	if (ioctl(fd, VFDSETLED, &data) < 0)
+	{
+		perror("VFDSETLED");
+	}
 	closeDevice();
 #endif
 }
@@ -656,22 +804,25 @@
 #if defined (ENABLE_4DIGITS)
 	ShowText("     "); // 5 empty digits
 #elif defined (__sh__)
+
+  #if defined (PLATFORM_KATHREIN)  /* using this otherwise VFD of ufs910 is black and Neutrino has a segfault */
 	struct vfd_ioctl_data data;
-	
-#if defined (PLATFORM_KATHREIN)		/* using this otherwise VFD of ufs910 is black and Neutrino has a segfault 		*/
+
 	data.start_address = 0x01;
 	data.length = 0x0;
 	openDevice();	
-	if (ioctl(fd, VFDDISPLAYCLR, &data) <0)
+	if (ioctl(fd, VFDDISPLAYCLR, &data) < 0)
+	{
 		perror("VFDDISPLAYCLR");
+	}
 	closeDevice();
-#else
-	data.start_address = 0;
-	openDevice();	
-	if( ioctl(fd, VFDDISPLAYWRITEONOFF, &data) < 0)
-		perror("VFDDISPLAYCLR");
-	closeDevice();
-#endif
+  #else
+	char buffer[VFD_LENGTH + 1];
+
+	memset(buffer, ' ', sizeof(buffer));
+	buffer[VFD_LENGTH] = 0;
+	ShowText(buffer);
+  #endif
 #elif (PLATFORM_COOLSTREAM)
 	int ret = ioctl(fd, IOC_VFD_CLEAR_ALL, 0);
 	if(ret < 0)
@@ -683,20 +834,57 @@
 #endif
 }
 
-void CVFD::ClearIcons()				/* switcht all VFD Icons off		*/
+void CVFD::ClearIcons()				/* switch all VFD Icons off */
 {
 	if(!has_lcd || is4digits) 
 		return;
 
 #if defined (__sh__)	
-#if defined(PLATFORM_SPARK7162)		/* using one command for switching off all Icons*/	 
+  #if defined(PLATFORM_SPARK7162)		/* using one command for switching off all Icons*/	 
 	openDevice();
 	aotom_data.u.icon.icon_nr = SPARK_ICON_ALL;
 	aotom_data.u.icon.on = 0;
 	if (ioctl(fd, VFDICONDISPLAYONOFF, &aotom_data) <0)
+	{
 		perror("VFDICONDISPLAYONOFF");
+	}	closeDevice();
+  #elif defined(BOXMODEL_FS9000) \
+     || defined(BOXMODEL_HS9510)  \
+     || defined(BOXMODEL_HS8200)   \
+     || defined(BOXMODEL_HS7420)       \
+     || defined(BOXMODEL_HS7810A)      \
+     || defined(BOXMODEL_HS7119)       \
+     || defined(BOXMODEL_HS7429)       \
+     || defined(BOXMODEL_HS7819)  /* using one command for switching off all Icons */
+  //#elif defined(PLATFORM_FORTIS)  /* using one command for switching off all Icons*/
+
+	struct vfd_ioctl_data data;
+
+	openDevice();
+	data.start_address = 0;
+	data.data[0] = ICON_ALL;
+	data.data[4] = 0;
+	data.length = 5;
+	if (ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+	{
+		perror("VFDICONDISPLAYONOFF");
+	}
 	closeDevice();
-#else
+  #elif defined(BOXMODEL_ADB_BOX)  /* using one command for switching off all Icons */
+
+	struct vfd_ioctl_data data;
+
+	openDevice();
+	data.start_address = 0;
+	data.data[0] = ADB_ICON_ALL;
+	data.data[4] = 0;
+	data.length = 5;
+	if (ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+	{
+		perror("VFDICONDISPLAYONOFF");
+	}
+	closeDevice();
+  #else
 	int i;
 	struct vfd_ioctl_data data;
 	
@@ -707,19 +895,21 @@
 		data.data[0] = i;
 		data.data[4] = 0;
 		
-		if( ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+		if (ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+		{
 			perror("VFDICONDISPLAYONOFF");
+		}
 	}
 	
 	closeDevice();
-#endif
+  #endif
 #endif
 }
 
 #if defined(PLATFORM_SPARK7162)			/* only for Spark7162 STB's which Display has a HDD Level indicator */	 
 void CVFD::ShowDiskLevel()
 {
-	int hdd_icons[9] = {24, 23, 21, 20, 19, 18, 17, 16, 22};
+	int hdd_icons[9] = {VFD_SPARK_HDD_A1, VFD_SPARK_HDD_A2, VFD_SPARK_HDD_A3, VFD_SPARK_HDD_A4, VFD_SPARK_HDD_A5, VFD_SPARK_HDD_A6, VFD_SPARK_HDD_A7, VFD_SPARK_HDD_A8, VFD_SPARK_HDD_FULL};
 	int percent, digits, i, j;
 	uint64_t t, u;
 	
@@ -752,13 +942,18 @@
 
 void CVFD::ShowIcon(vfd_icon icon, bool show)
 {
-	if(!has_lcd || is4digits) 
+	if(!has_lcd || is4digits || icon == 0) 
 		return;
 	
 	dprintf(DEBUG_DEBUG, "CVFD::ShowIcon %s %x\n", show ? "show" : "hide", (int) icon);
 
 #if defined (__sh__)
-#if defined (PLATFORM_KATHREIN) || defined(PLATFORM_SPARK7162)
+  #if defined (PLATFORM_KATHREIN) \
+   || defined(PLATFORM_SPARK7162) \
+   || defined(BOXMODEL_FS9000) \
+   || defined(BOXMODEL_HS9510) \
+   || defined(BOXMODEL_HS8200) \
+   || defined(BOXMODEL_ADB_BOX)
 	switch (icon)
 	{
 		case VFD_ICON_USB:
@@ -767,31 +962,53 @@
 		case VFD_ICON_CLOCK:
 			timer_icon = show;
 			break;
-#if defined (PLATFORM_KATHREIN)
+    #if defined (PLATFORM_KATHREIN) || defined(PLATFORM_HS9510)
 		case VFD_ICON_HDD:
 			hdd_icon = show;
 			break;
-#endif
+    #endif
 		default:
 			break;
 	}
-#endif
+  #endif
 
 	openDevice();
-#if defined(PLATFORM_SPARK7162)
+  #if defined(PLATFORM_SPARK7162)
 	aotom_data.u.icon.icon_nr = icon;
 	aotom_data.u.icon.on = show ? 1 : 0;
 	
-	if (ioctl(fd, VFDICONDISPLAYONOFF, &aotom_data) <0)
+	if (ioctl(fd, VFDICONDISPLAYONOFF, &aotom_data) < 0)
+	{
 		perror("VFDICONDISPLAYONOFF");	
+	}
+  #elif defined(BOXMODEL_FS9000) \
+     || defined(BOXMODEL_HS9510) \
+     || defined(BOXMODEL_HS8200) \
+     || defined(BOXMODEL_HS7420) \
+     || defined(BOXMODEL_HS7810A) \
+     || defined(BOXMODEL_HS7119) \
+     || defined(BOXMODEL_HS7429) \
+     || defined(BOXMODEL_HS7819) \
+     || defined(BOXMODEL_ADB_BOX)
+	struct vfd_ioctl_data data;
+
+	data.start_address = 0;
+	data.data[0] = icon;
+	data.data[4] = show ? 1 : 0;
+	data.length = 5;
+
+  	if (ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+	{
+		perror("VFDICONDISPLAYONOFF");
+	}
 #else
-#if defined (PLATFORM_KATHREIN)
+    #if defined (PLATFORM_KATHREIN)
 	if (icon == 17)				/* returning because not existing icon at ufs910 */
 	{
 		closeDevice();	
 		return;
 	}
-#endif	
+    #endif	
 	struct vfd_ioctl_data data;
 
 	data.data[0] = (icon - 1) & 0x1F;
@@ -799,7 +1016,7 @@
 	
 	if( ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
 		perror("VFDICONDISPLAYONOFF");
-#endif	
+  #endif	
 	closeDevice();
 #elif defined (PLATFORM_COOLSTREAM)
 	int ret = ioctl(fd, show ? IOC_VFD_SET_ICON : IOC_VFD_CLEAR_ICON, icon);
@@ -816,11 +1033,20 @@
 	dprintf(DEBUG_INFO, "CVFD::ShowText: [%s]\n", str);
 
 	int len = strlen(str);
+	if (len > 63)
+	{
+//		str[60] = '.';
+//		str[61] = '.';
+//		str[62] = '.';
+//		str[63] = '\0';
+		len = 63;
+	}
 	
 	//FIXME: some vfd treiber can not handle NULL string len
-	if(len == 0)
-		return;
-	
+	if (len == 0)
+	{
+		return;
+	}	
 	// replace
 	std::string text = str;
 
@@ -839,32 +1065,43 @@
 	 
 #if defined (__sh__)	 
 	openDevice();
-	
-	if(write(fd , text.c_str(), len > 16? 16 : len ) < 0)
+//  #if defined(BOXMODEL_HS9510) || defined(BOXMODEL_HS7420) || defined(BOXMODEL_HS7429)
+//	if (write(fd, text.c_str(), len > 8 ? 8 : len ) < 0)
+//  #elif defined(BOXMODEL_FS9000) || defined(BOXMODEL_HS8200)
+//	if (write(fd, text.c_str(), len > 12 ? 12 : len ) < 0)
+//  #elif defined(BOXMODEL_HS7810A) || defined(BOXMODEL_HS7119) || defined(BOXMODEL_HS7819)
+//	if (write(fd, text.c_str(), len > 4 ? 4 : len ) < 0)
+//  #else
+//	if (write(fd, text.c_str(), len > 16 ? 16 : len ) < 0)
+//  #endif
+	if (write(fd, text.c_str(), len > VFD_LENGTH ? VFD_LENGTH : len) < 0)
+//	if (write(fd, text.c_str(), len) < 0) // let driver do the scrolling
+	{
+		perror("write to /dev/vfd failed");
+	}
+	closeDevice();
+#else
+  #if defined (PLATFORM_ODIN) || defined (PLATFORM_GIGABLUE)
+	if (write(fd, text.c_str(), len > 5 ? 5 : len ) < 0)
+  #else
+	if (write(fd, text.c_str(), len > 12 ? 12 : len ) < 0)
+  #endif
 		perror("write to vfd failed");
-	
+#endif // __sh__
+}
+
+void CVFD::setFan(bool enable)
+{
+#if defined (__sh__)
+  #if defined(BOXMODEL_ADB_BOX)
+	 openDevice();
+	
+	if (ioctl(fd, VFDSETFAN, enable) < 0)  
+	{
+		perror("VFDSETFAN");
+	}
 	closeDevice();
-#elif defined (PLATFORM_ODIN) || defined (PLATFORM_GIGABLUE)
-	if( write(fd, text.c_str(), len > 5? 5 : len ) < 0)
-		perror("write to vfd failed");
-#else
-	if( write(fd, text.c_str(), len > 12? 12 : len ) < 0)
-		perror("write to vfd failed");
-	
-#endif
-}
-
-void CVFD::setFan(bool enable)
-{
-#if defined (__sh__)
-	/*
-	 openDevice();
-	
-	if( ioctl(fd, VFDSETFAN, enable) < 0)  
-		perror("VFDSETFAN");
-	
-	closeDevice();
-	*/
+  #endif
 #endif	
 }
 
@@ -919,7 +1156,11 @@
 	
 	dprintf(DEBUG_NORMAL, "CVFD::vfd_symbol_circle: %s\n", VFDCIRCLE[cir]);
 	
-#if defined (PLATFORM_VENTON)	
+#if defined (PLATFORM_VENTON) \
+ || defined (BOXMODEL_HS8200) \
+ || defined (BOXMODEL_FS9000) \
+ || defined (BOXMODEL_TF7700) \
+ || defined (BOXMODEL_ADB_BOX)
 	FILE *f;
 	if((f = fopen("/proc/stb/lcd/symbol_circle","w")) == NULL) 
 	{
@@ -949,14 +1190,14 @@
 	timebuf[2]=now->tm_hour;
 	timebuf[3]=now->tm_mday;
 	timebuf[4]=now->tm_mon+1;
-	timebuf[5]=now->tm_year % 100;
+	timebuf[5]=now->tm_year % 100; // BUG?, should be - 1900?
 	
 	struct vfd_ioctl_data data;
 	memset(&data, 0, sizeof(struct vfd_ioctl_data));
 	memcpy(&data, timebuf, 6); 
 	
 	if( ioctl(fd, VFDSETTIME, &data) < 0)  
-		perror("VFDPWRLED");
+		perror("VFDSETTIME");
 	
 	closeDevice();
 #endif
@@ -973,3 +1214,4 @@
 		ShowText(tmp); // UTF-8
 	}
 }
+// vim:ts=4
--- nhd2-exp.org/src/nhttpd/tuxboxapi/neutrinoyparser.cpp
+++ nhd2-exp/src/nhttpd/tuxboxapi/neutrinoyparser.cpp
@@ -671,14 +671,40 @@
 std::string  CNeutrinoYParser::func_get_boxtype(CyhookHandler *, std::string)
 {
 	//return "generic";//FIXME
-#if defined (BOXMODEL_ATEVIO700)
-	return "atevio700";
-#elif defined (BOXMODEL_ATEVIO7000)
-	return "atevio7000";
-#elif defined (BOXMODEL_ATEVIO7500)
-	return "atevio7500";
-#elif defined (BOXMODEL_ATEVIO7600)
-	return "atevio7600";
+#if defined (BOXMODEL_HS8200)
+	return "hs82000";
+#elif defined (BOXMODEL_FS9000)
+	return "fs9000";
+#elif defined (BOXMODEL_HS9510)
+	return "hs9510";
+#elif defined (BOXMODEL_HS7110)
+	return "hs7110";
+#elif defined (BOXMODEL_HS7420)
+	return "hs7420";
+#elif defined (BOXMODEL_HS7810a)
+	return "hs7810a";
+#elif defined (BOXMODEL_HS7119)
+	return "hs7119";
+#elif defined (BOXMODEL_HS7429)
+	return "hs7429";
+#elif defined (BOXMODEL_HS7819)
+	return "hs7819";
+#elif defined (BOXMODEL_TF7700)
+	return "tf7700";
+#elif defined (BOXMODEL_ADB_BOX)
+	return "adb_box";
+#elif defined (BOXMODEL_ADB2850)
+	return "adb2850";
+#elif defined (BOXMODEL_VIP1_V1)
+	return "vip1_v1";
+#elif defined (BOXMODEL_VIP1_V2)
+	return "vip1_v2";
+#elif defined (BOXMODEL_VIP2)
+	return "vip2";
+#elif defined (BOXMODEL_VITAMIN_HD5000)
+	return "vitamin_hd5000";
+#elif defined (BOXMODEL_OP9600)
+	return "opt9600";
 #elif defined (BOXMODEL_AZBOXHD)
 	return "azboxhd";
 #elif defined (BOXMODEL_AZBOXME)
--- nhd2-exp.org/data/locale/english.locale
+++ nhd2-exp/data/locale/english.locale
@@ -20,17 +20,17 @@
 audiomenu.monoright mono right
 audiomenu.ost ost
 audiomenu.PCMOffset Volume Decrease PCM
-audiomenu.spdif_dd DD on SPDIF
+audiomenu.spdif_dd DD on SP/DIF
 audiomenu.stereo stereo
 audiomenu.ac3_delay AC3 Delay
 audiomenu.pcm_delay PCM Delay
 audiomenu.volume_adjust Volume adjustment (in %)
 audiomenu.auto_lang Auto select audio
 audiomenu.auto_subs Auto select subtitles
-audiomenu.pref_lang Prefered language
+audiomenu.pref_lang Preferred language
 audiomenu.pref_lang_head Audio language preferences
 audiomenu.pref_languages Language preferences
-audiomenu.pref_subs Prefered subtitle language
+audiomenu.pref_subs Preferred subtitle language
 audiomenu.pref_subs_head Subtitle language preferences
 audioplayer.add Add
 audioplayer.add_ic Icecast
@@ -85,14 +85,14 @@
 bookmarkmanager.rename rename
 bookmarkmanager.select select
 bouqueteditor.add Add
-bouqueteditor.bouquetname Name of bouquets
+bouqueteditor.bouquetname Name of bouquet
 bouqueteditor.delete Delete
 bouqueteditor.discardingchanges Discarding changes. Please be patient.
 bouqueteditor.hide Hide
 bouqueteditor.lock Lock
 bouqueteditor.move Move
 bouqueteditor.name Bouquet Editor
-bouqueteditor.newbouquetname New name of bouquets
+bouqueteditor.newbouquetname New name of bouquet
 bouqueteditor.rename Rename
 bouqueteditor.return ready
 bouqueteditor.savechanges? Do you want to save the changes?
@@ -120,7 +120,7 @@
 channellist.history History
 channellist.make_hdlist Create list of HD channels
 channellist.ca Display Icons
-channellist.nonefound No channels were found!\nPlease execute a scan\n(MENU-key -> service)
+channellist.nonefound No channels were found!\nPlease execute a scan\n(MENU-key -> Service)
 channellist.provs Providers
 channellist.sats Satellites
 channellist.since since %02d:%02d
@@ -157,8 +157,8 @@
 colorthememenu.save Save current theme
 colorthememenu.select1 User Theme
 colorthememenu.select2 Standard Theme
-colormenu.head_title Head info
-colormenu.foot_title Foot info
+colormenu.head_title Header info
+colormenu.foot_title Footer info
 cpu.freq Cpu frequency
 cpu.freq_default default frequency
 cpu.freq_normal Normal frequency
@@ -260,8 +260,8 @@
 extra.auto_timeshift Permanent timeshift
 extra.auto_to_record Move timeshift to records
 extra.cache_txt Cache teletext
-extra.chadded The current channel has been added to selected bouquet....\n
-extra.chalreadyinbq The current channel is already in selected bouquet....\n
+extra.chadded The current channel has been added to selected bouquet...\n
+extra.chalreadyinbq The current channel is already in selected bouquet...\n
 extra.clear_log Clear Log
 extra.dboxinfo Box Info
 extra.east East
@@ -360,7 +360,7 @@
 extra.zapit_backup Backup channels to /tmp
 extra.zapit_fast_zap fast zap
 extra.zapit_fe_timeout Tune timeout
-extra.zapit_hvoltage High (13.5/18.5) voltage
+extra.zapit_hvoltage High voltage (13.5/18.5V)
 extra.zapit_make_bouquet Make Remaining Channels list
 extra.zapit_menu Zapit options
 extra.zapit_motor_speed Motor moving speed (10 = 1deg/sec)
@@ -379,7 +379,7 @@
 favorites.chadded The current channel has been added to your favorites...\n
 favorites.chalreadyinbq The current channel is already in your favorites...\n
 favorites.copy Copy bouquet to Favorites
-favorites.finalhint \nUse the bouqueteditor to modify your favorites.\n
+favorites.finalhint \nUse the bouquet editor to modify your favorites.\n
 favorites.menueadd add channel to my favorites
 favorites.nobouquets Favorites are available with activated Bouquets only.
 filebrowser.delete Delete
@@ -430,7 +430,7 @@
 flashupdate.packagemd5sumerror package has errors
 flashupdate.flashmsgbox Found the following new image:\nDate: %s, %s\nBaseImage: %s\nImageType: %s\n\nDo you want to install this version now?
 flashupdate.packagemsgbox Found the following new package:\nPackage: %s\nDate: %s, %s\nBaseImage: %s\nType: %s\n\nDo you want to download and install this version now?
-flashupdate.mtdselector Partition-Selector
+flashupdate.mtdselector Partition Selector
 flashupdate.programmingflash programming flash
 flashupdate.proxypassword Password
 flashupdate.proxypassword_hint1 enter the proxyserver password
@@ -453,7 +453,7 @@
 flashupdate.titlewriteflash Writing Flash
 flashupdate.updatemode Updatemode
 flashupdate.updatemode_internet Online Software Manager
-flashupdate.updatemode_manual Manuell(ftp) Software Manager
+flashupdate.updatemode_manual Manual (FTP) Software Manager
 flashupdate.url_file Software update URL
 flashupdate.versioncheck checking version
 flashupdate.writeflash Write whole image
@@ -472,8 +472,8 @@
 fontmenu.scaling Global Font Zoom Factor
 fontmenu.scaling_x Horizontal (in %)
 fontmenu.scaling_x_hint2 Horizontal (in %) min 50 / max 200
-fontmenu.scaling_y Vertikal (in %)
-fontmenu.scaling_y_hint2 Vertikal (in %) min 50 / max 200
+fontmenu.scaling_y Vertical (in %)
+fontmenu.scaling_y_hint2 Vertical (in %) min 50 / max 200
 fontmenu.font_contrast Contrast fonts
 fontsize.channel_num_zap direct selection
 fontsize.channellist Channellist
@@ -589,17 +589,17 @@
 hdd_fast Fast
 hdd_format Format HDD
 hdd_format_failed HDD format failed !
-hdd_format_warn Are you sure to format ? You will lost all data !
-hdd_init_failed HDD init failed !
+hdd_format_warn Are you sure to format ? You will lose all data !
+hdd_init_failed HDD initialise failed !
 hdd_fs Filesystem
 hdd_manage Manage
 hdd_middle Middle
 hdd_noise Noise
 hdd_not_found No HDD found
 hdd_init HDD Init
-hdd_init_warn Are you sure to init ?
+hdd_init_warn Are you sure to initialise ?
 hdd_browser HDD Explorer
-hdd_reiser Reiserfs
+hdd_reiser Reiser fs
 hdd_settings HDD Settings
 hdd_sleep Sleep time
 hdd_slow Slow
@@ -615,7 +615,7 @@
 imageinfo.version Version:
 imageinfo.type Type:
 inetradio.name Internetradio
-infoviewer.epgnotload EPG not loaded....
+infoviewer.epgnotload EPG not loaded...
 infoviewer.epgwait waiting for EPG...
 infoviewer.eventlist Event-List
 infoviewer.languages Audio
@@ -629,7 +629,7 @@
 infoviewer.features Features
 infoviewer.subchan_disp_pos Subchannel display
 infoviewer.subservice Subservices
-infoviewer.waittime Waiting for time...
+infoviewer.waittime Waiting for timeinfo...
 ipsetup.hint_1 Use 0..9, or use Up/Down,
 ipsetup.hint_2 OK saves, HOME! aborts
 keybindingmenu.addrecord Add record timer
@@ -756,7 +756,7 @@
 miscsettings.channellist_epgtext_align Programtext Align
 miscsettings.driver_boot driver and boot options
 miscsettings.epg_cache EPG-Cache (Days)
-miscsettings.epg_cache_hint1 How long will EPG-Data in the future cached?
+miscsettings.epg_cache_hint1 How long will futue EPG-Data be cached?
 miscsettings.epg_cache_hint2 Set in days.
 miscsettings.epg_dir EPG save path
 miscsettings.epg_extendedcache EPG Long Description (hours)
@@ -766,8 +766,8 @@
 miscsettings.epg_max_events Max. Events
 miscsettings.epg_max_events_hint1 How many events should be stored?
 miscsettings.epg_max_events_hint2 normaly 50000, 0 to disable limit
-miscsettings.epg_old_events EPG remove after (std.)
-miscsettings.epg_old_events_hint1 How long will EPG-Data be stored after they timed out?
+miscsettings.epg_old_events EPG remove after (hrs.)
+miscsettings.epg_old_events_hint1 How long will EPG-Data be stored after it times out?
 miscsettings.epg_old_events_hint2 Set in hours
 miscsettings.epg_read Restore EPG on boot
 miscsettings.epg_save Save/Restore epg on reboot
@@ -873,7 +873,7 @@
 moviebrowser.info_filename Name
 moviebrowser.info_genre_major Genre
 moviebrowser.info_genre_minor Genre
-moviebrowser.info_head Film Informationen
+moviebrowser.info_head Film Information
 moviebrowser.info_head_update Save changes in all movie info files
 moviebrowser.info_info1 Info 1
 moviebrowser.info_info2 Info 2
@@ -915,7 +915,7 @@
 moviebrowser.reload_at_start Reload movie info at start
 moviebrowser.remount_at_start Remount at start
 moviebrowser.next_focus next focus
-moviebrowser.scan_for_movies Scan for Movies ...
+moviebrowser.scan_for_movies Scan for Movies...
 moviebrowser.prefer_tmdb_info prefer TMDB infos
 moviebrowser.serie_auto_create Serie auto create
 moviebrowser.serie_head Serie
@@ -956,8 +956,8 @@
 movieplayer.vlcplayback VLC Player
 movieplayer.vlcdvdplayback VLC (DVD) Player
 movieplayer.vlcsvcdplayback VLC (SVCD) Player
-movieplayer.records Records Player
-movieplayer.movies Movies Player
+movieplayer.records Recordings Player
+movieplayer.movies Movie Player
 movieplayer.fileplayback Media Player
 movieplayer.showtshelp Help
 movieplayer.goto Jump to ...
@@ -998,7 +998,7 @@
 movieplayer.vlchelp7 skip approx. 1 minute
 movieplayer.vlchelp8 approx. 5 minutes back
 movieplayer.vlchelp9 skip approx. 5 minutes
-movieplayer.wrongvlcversion This feature is not support by your current version of VLC
+movieplayer.wrongvlcversion This feature is not supported by your current version of VLC
 mpkey.audio Audio track
 mpkey.bookmark Save bookmark
 mpkey.forward Forward
@@ -1056,7 +1056,7 @@
 nfs.umount Umount Network volume
 nfs.umounterror error umounting volume
 nfs.username username
-nfsmenu.head Network Mount Manager
+nfsmenu.head Network mount manager
 nvod.percentage (%d%% over)
 nvod.starting (starting in %d min)
 nvodselector.directormode Direct-Mode
@@ -1126,8 +1126,8 @@
 ping.protocol is unreachable (host or protocol error)
 ping.socket is unreachable (socket error)
 ping.unreachable is unreachable
-pinprotection.head Enter PIN code
-pinprotection.wrongcode PIN-Code was wrong! Try again.
+pinprotection.head Enter PIN
+pinprotection.wrongcode PIN was wrong! Try again.
 plugins.notinstalled is not installed please install again.
 plugins.result plugin output
 pluginlist.remove_plugin remove
@@ -1135,7 +1135,7 @@
 rclock.lockmsg Your box remote control will be locked.\n To unlock it, press <RED> \n and <MENU> on your remote control.
 rclock.menueadd Lock RC
 rclock.title Lock Remote Control
-rclock.unlockmsg Remote control reactivated.
+rclock.unlockmsg Remote control reactivated
 recordingmenu.apids default audio streams
 recordingmenu.apids_ac3 Record AC3 streams
 recordingmenu.apids_alt Record alternative streams
@@ -1147,7 +1147,7 @@
 recordingmenu.filesettings direct Recording settings
 recordingmenu.head Recording Settings
 recordingmenu.help Recording devices:\n--------------------------\nserver:\nusing streaming software on a PC\n\n(analog) vcr:\nusing the vcr outlet\n\ndirect (file):\ndirectly into an NFS mounted directory\nor onto an internal hard drive\nTS: use spts mode(dbox2)\nPES: do not use spts mode(dbox2)\n\n\nMax. file size:\n---------------------\nNFS V2: 2 GB (2048 MB)\nNFS V3: almost unlimited (0 MB)\nFAT: 2 GB (2048 MB)\nFAT32: 4 GB (4096 MB)
-recordingmenu.no_scart do not switch to scart mode
+recordingmenu.no_scart do not switch to SCART mode
 recordingmenu.off off
 recordingmenu.record_in_spts_mode switch to spts mode before recording
 recordingmenu.recording_type recording device
@@ -1378,7 +1378,7 @@
 timerlist.repeat.weekdays on weekdays
 timerlist.repeat.weekly weekly
 timerlist.repeatcount repeats
-timerlist.repeatcount.help1 amount of timer repeats
+timerlist.repeatcount.help1 number of timer repeats
 timerlist.repeatcount.help2 0 for unlimited repeats
 timerlist.save Save timer
 timerlist.standby SB mode
@@ -1428,10 +1428,10 @@
 usermenu.button_green User menu green
 usermenu.button_red User menu red
 usermenu.button_yellow User menu yellow
-usermenu.button_f1 Benutzermenü F1
-usermenu.button_f2 Benutzermenü F2
-usermenu.button_f3 Benutzermenü F3
-usermenu.button_f4 Benutzermenü F4
+usermenu.button_f1 User menu F1
+usermenu.button_f2 User menu F2
+usermenu.button_f3 User menu F3
+usermenu.button_f4 User menu F4
 usermenu.head User menu
 usermenu.item_bar ---- Border ----
 usermenu.item_epg_misc EPG functions
@@ -1441,14 +1441,14 @@
 usermenu.name Name
 video_mode_ok Is this video mode working ok ?
 videomenu.analog_hd_rgb_cinch RGB on cinch (HD)
-videomenu.analog_hd_rgb_scart RGB on scart (HD)
+videomenu.analog_hd_rgb_scart RGB on SCART (HD)
 videomenu.analog_hd_yprpb_cinch YPbPr on cinch (HD)
-videomenu.analog_hd_yprpb_scart YPbPr on scart (HD)
+videomenu.analog_hd_yprpb_scart YPbPr on SCART (HD)
 videomenu.analog_mode Analog Output
 videomenu.analog_sd_rgb_cinch RGB on cinch (SD)
-videomenu.analog_sd_rgb_scart RGB on scart (SD)
+videomenu.analog_sd_rgb_scart RGB on SCART (SD)
 videomenu.analog_sd_yprpb_cinch YPbPr on cinch (SD)
-videomenu.analog_sd_yprpb_scart YPbPr on scart (SD)
+videomenu.analog_sd_yprpb_scart YPbPr on SCART (SD)
 videomenu.auto Auto
 videomenu.cinch Cinch
 videomenu.csync sync correction
@@ -1465,33 +1465,33 @@
 videomenu.scart Scart
 videomenu.screensetup Screen settings
 videomenu.tv-scart Video
-videomenu.vcr-scart VCR Scart
+videomenu.vcr-scart VCR SCART
 videomenu.vcrsignal VCR Output Signal Type
 videomenu.vcrsignal_composite CVBS
 videomenu.vcrsignal_svideo S-Video
-videomenu.vcrswitch Switch Scart automatically
+videomenu.vcrswitch Switch SCART automatically
 videomenu.videoratio TV-System
 videomenu.videoratio_149 14:9
 videomenu.videoratio_169 16:9
 videomenu.videoratio_43 4:3
 videomenu.videoratio_autodetect autodetect
 videomenu.videoformat Video Format
-videomenu.panscan Panscan
+videomenu.panscan Pillarbox
 videomenu.panscan2 Bestfit
 videomenu.letterbox Letterbox
-videomenu.fullscreen Vollbild
+videomenu.fullscreen Full screen
 videomenu.videomode Video Resolution
 zapit.scantype Scan for services
 zapit.scantype.all All services
 zapit.scantype.radio Only radio
 zapit.scantype.tv Only tv
 zapit.scantype.tvradio TV & Radio
-zaptotimer.announce Zapto timer in one minute
-hddmenu.hddmount HDD (Re)Mount
-hddmenu.hddmounted HDD Mounted
-hddmenu.hddmountfailed HDD Mount Failed
-hddmenu.hddumount HDD Umount
-hddmenu.hddumounted HDD Umounted
+zaptotimer.announce Zap to timer in one minute
+hddmenu.hddmount HDD (Re)mount
+hddmenu.hddmounted HDD mounted
+hddmenu.hddmountfailed HDD mount failed
+hddmenu.hddumount HDD unmount
+hddmenu.hddumounted HDD unmounted
 mainmenu.mediaplayer Media Player
 osd.timezone Time Zone
 osd.corners OSD Corners
@@ -1593,7 +1593,7 @@
 psisetup.tint Tint
 
 colormenu.helptxt Help text
-colormenu.helpbar Foot bar
+colormenu.helpbar Footer bar
 
 lcdmenu.menutitlevfd show Menu title on Display
 
@@ -1609,7 +1609,7 @@
 
 opkgmanager.head Software update manager
 
-keybinding.key_recordsbrowser Records browser
+keybinding.key_recordsbrowser Recordings browser
 keybinding.key_audioplayer Audioplayer
 keybinding.key_pictureviewer PictureViewer
 keybinding.key_timerlist Timerlist
@@ -1686,7 +1686,7 @@
 glcd.enable GraphLCD enabled
 glcd.font Font
 glcd.head GraphLCD
-glcd.mirror_osd Show OSD menue on GraphLCD
+glcd.mirror_osd Show OSD menu on GraphLCD
 glcd.restart Rescan
 glcd.select.bar Progress bar color
 glcd.select.bg Background color
--- neutrino-hd2.org/src/gui/imageinfo.cpp
+++ neutrino-hd2/src/gui/imageinfo.cpp
@@ -40,7 +40,7 @@
 
 #include <video_cs.h>
 
-#include <gui/version.h>
+#include "version.h"
 
 
 #define GIT_BUILD "GIT Build:"

